# Справочник C++

## Содержание

[1. Потоковый ввод и вывод](#IO)

[2. Типы данных](#data)

[3. Ветвления и циклы](#cicles)

[4. Векторы и строки](#vector)

[5. Генерация случайных чисел в языке Си](#rand)

[6. Условные операторы](#operators)

[7. Функции и указатели](#functions)

<a name="IO"><h2>1. Потоковый ввод и вывод</h2></a>

Для работы с потоковым вводом и выводом необходимо подключить стандартную библиотеку `iostream`

`#include <iostream>`

Конструкции из этой библиотеки предваряются префиксом `std::` который обозначает пространство имен

`std::cout` позволяет вывести информацию 

`std::cin` позволяет получить данные с клавиатуры. Данный оператор читает данные до ближайшего разделителя. 

```
#include <iostream>
#include <string>

int main() {
    std::string name;  // объявляем переменную name
    std::cout << "What is your name?\n";
    std::cin >> name;  // считываем её значение с клавиатуры
    std::cout << "Hello, " << name << "!\n";
}
```

Чтобы читать всю строчку целиком, необходимо использовать функцию `std::getline` из библиотеки `#include <string>`.

<a name="data"><h2>2. Типы данных</h2></a>

Язык С++ имеет статическую типизацию данных

Фундаментальные типы данных в языке С++

```
int main() {
    char c = '1';    // символ
    bool b = true;   // логическая переменная, принимает значения false и true
    int i = 42;      // целое число (занимает, как правило, 4 байта)
    short int si = 17;           // короткое целое (занимает 2 байта)
    long li = 12321321312;       // длинное целое (как правило, 8 байт)
    long long lli = 12321321312; // длинное целое (как правило, 8 байт)
    float f = 2.71828;           // дробное число с плавающей запятой (4 байта)
    double d = 3.141592;         // дробное число двойной точности (8 байт)
    long double ld = 1e15;       // длинное дробное (как правило, 16 байт)
}
```

#### Автомитический вывод типа

Компилятор С++ умеет автоматически выводить тип переменной по значению которое ей присваивается. Для этого вместо типа данных нужно написать `auto`.

```
int main() {
    auto x = 42;  // int
    auto pi = 3.14159;  // double
}

```

<a name="cicles"><h2>3. Ветвления и циклы</h2></a>

Основные циклы, такие как `if` `for` `while` `switch` разобраны в [справочнике по Си](https://github.com/denismox/STM32HAL/blob/main/C%20lessons.md#cycle) и идентичны им и в С++

#### Цикл range-based for

Данный цикл позволяет перебрать все элементы контейнера (массива, вектора, списки, строки и некоторые пользовательские классы если они поддерживают нужный интерфейс)

Синтаксис выглядит следущим образом:

```
for(auto declaration : container){
    //loop body
}
```

`declaration` - переменная которая будет последовательно принимать значения элементов контейнера

`container` - обьект который можно обойти (array, vector, map, строка, initializer list и т.д.)

```
#include <iostream>
#include <string>

int main() {
    std::string line;
    std::getline(std::cin, line);
    for (char symbol : line) {
        std::cout << symbol << "\n";
    }
}
```

<a name="vector"><h2>4. Векторы и строки</h2></a>

Вектор `std::vector` и строка `std::string` - это базовые контейнеры стандартной библиотеки С++. Они хранят свои элементы в непрерывном фрагменте памяти. Оба этих элемента предоставляют доступ к элементам по индексу и позволяют эффективно добавлять элементы в конец

Вектор - это динамический массив который позволяет эффективно добавлять новые элементы в конец и при необходимости изменять свой размер. Вектор гарантирует отсутствие утечек памяти.

Элементы вектора должны быть одного типа и этот тип должен быть известен при компиляции 

`std::vector<int> vector_name` - вектор vector_name с элементами типа int 

`std::vector<std::string> vector_name` - вектор vector_name с элементами типа std::string

Пример программы которая заполняет вектор элементами и печатает их через пробел

```
#include <iostrem>
#include <vector>

int main(){
    std::vector<int> data = {1, 2, 3, 4, 5};
    for (int elem : data){
        std::cout << elem << " ";

    }
    return 0;
}
```

Здесь вектор инициализируется через список инициализации, в котором элементы перечислены через запятую. Другой способ инициализации вектора - указать число элементов и при необходимости образец элемента

```
std::vector<std::string> v1;                //пустой вектор
std::vector<std::string> v2(5);             //вектор из пяти пустых строк
std::vector<std::string> v3(5, "hello");    //вектор из пяти пустых строк hello
```

#### Обращение к элементам

В примере выше для работы с элементами массива использовался цикл range-for. Иногда удобнее работать с индексами. Вектор хранит элементы в памяти последовательно, поэтому по индексу элемента можно быстро найти его положение в памяти. Индексация начинается с нуля.

```
std::vector<int> data = {1, 2, 3, 4, 5};
int a = data[0];
int b = data[4];
data[2] = -3;
```

Чтобы узнать общее количество элементов в векторе можно воспользоваться функцией `size`

```
std::vector<int> data = {1, 2, 3, 4, 5};
std::cout << data.size();
```

Индекс не может быть отрицательным, если обратиться к вектору по некорректному индексу, то программа во время выполнения попадет в неопределенное поведение: фактически она попытается прочитать память, не принадлежащую вектору. Считается что программист понимает сам корректность индекса, однако если он не уверен в его корректности то можно использовать функцию `at`

```
std::vector<int> data = {1, 2, 3, 4, 5};
std::cout << data[42];                    //неопределенное поведение, может произойти все что угодно
std::cout << data.at(0);                  //напечатается 1
std::cout << data.at(42);                 //Произойдет исключение std::out_of_range - его можно перехватить и обработать
```

Функции вектора `front` и `back` возвращают первый и последний элемент вектора без использования индексов. __Применение этих функций на пустом векторе приведет к неопределенному поведению__

```
std::vector<int> data = {1, 2, 3, 4, 5};
std::cout << data.front();                //Напечатет 1, тоже что и data[0]
std::cout << data.back();                 //Напечатет 5, тоже что и data[data.size - 1]
```

Для проверки вектора на пустоту вместо сравнения `data.size() == 0` принято использоавать функцию `empty`, которая возвращает логическое значение

```
if(!data.empty()){
    //вектор не пуст с ним можно работать
}
```

#### Итерация по индексам

В стандартной библиотеке индексы и размеры контейнеров имеют беззнаковый целочисленнный тип `size_t` который в зависимости от системы будет совпадать с `uint32_t` или `uint64_t`

Итерацию по индесам принято производить так:

```
for(size_t i = 0; i != data.size; ++i){
    std::cout << data[i] << " ";
}
```

#### Добавление и удаление элементов

Для добавления и удаления элементов в конец вектора можно использовать функции `push_back` и `pop_back` соответственно. 

```
#include <iostream>
#include <vector>

int main(){
    int x;
    std::vector<int> data;
    while(std::cin >> x){
        data.push_back(x);        //Вставляет элемент в конец вектора data
    }
    while(!data.empty() && data.back() == 0){
        data.pop_back();          //Удаляем последний элемент пока вектор не пуст и последний элемент нулевой
    }
    return 0;
}
```

Добавление/удаление элементов из других частей массива неэффективно поскольку требует сдвига других элементов вектора. Очистить все элементы вектора можно при помощи функции `clear`

#### Резерв памяти

Вектор хранит элементы в памяти в виде непрерывной последовательности, друг за другом. При этом в конце резервируется дополнительное место для быстрого добавления новых элементов. Когда этот резерв заканчивается происходит реаллокация: элементы вектора копируются в новый более просторный блок памяти. Текущий размер вектора можно узнать при помощи функции `capacity`.

```
#include <iostream>
#include <vector>

int main() {
    std::vector<int> data = {1, 2};
    std::cout << data.size() << "\t" << data.capacity() << "\n";

    data.push_back(3);
    std::cout << data.size() << "\t" << data.capacity() << "\n";

    data.push_back(4);
    std::cout << data.size() << "\t" << data.capacity() << "\n";

    data.push_back(5);
    std::cout << data.size() << "\t" << data.capacity() << "\n";
}
```

Программа выдаст следущее:
```
2	2
3	4
4	4
5	8
```
