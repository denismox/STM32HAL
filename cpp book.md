# Справочник C++

## Содержание

[1. Потоковый ввод и вывод](#IO)

[2. Типы данных](#data)

[3. Ветвления и циклы](#cicles)

[4. Векторы и строки](#vector)

[5. Генерация случайных чисел в языке Си](#rand)

[6. Условные операторы](#operators)

[7. Функции и указатели](#functions)

<a name="IO"><h2>1. Потоковый ввод и вывод</h2></a>

Для работы с потоковым вводом и выводом необходимо подключить стандартную библиотеку `iostream`

`#include <iostream>`

Конструкции из этой библиотеки предваряются префиксом `std::` который обозначает пространство имен

`std::cout` позволяет вывести информацию 

`std::cin` позволяет получить данные с клавиатуры. Данный оператор читает данные до ближайшего разделителя. 

```
#include <iostream>
#include <string>

int main() {
    std::string name;  // объявляем переменную name
    std::cout << "What is your name?\n";
    std::cin >> name;  // считываем её значение с клавиатуры
    std::cout << "Hello, " << name << "!\n";
}
```

Чтобы читать всю строчку целиком, необходимо использовать функцию `std::getline` из библиотеки `#include <string>`.

<a name="data"><h2>2. Типы данных</h2></a>

Язык С++ имеет статическую типизацию данных

Фундаментальные типы данных в языке С++

```
int main() {
    char c = '1';    // символ
    bool b = true;   // логическая переменная, принимает значения false и true
    int i = 42;      // целое число (занимает, как правило, 4 байта)
    short int si = 17;           // короткое целое (занимает 2 байта)
    long li = 12321321312;       // длинное целое (как правило, 8 байт)
    long long lli = 12321321312; // длинное целое (как правило, 8 байт)
    float f = 2.71828;           // дробное число с плавающей запятой (4 байта)
    double d = 3.141592;         // дробное число двойной точности (8 байт)
    long double ld = 1e15;       // длинное дробное (как правило, 16 байт)
}
```

#### Автомитический вывод типа

Компилятор С++ умеет автоматически выводить тип переменной по значению которое ей присваивается. Для этого вместо типа данных нужно написать `auto`.

```
int main() {
    auto x = 42;  // int
    auto pi = 3.14159;  // double
}

```

<a name="cicles"><h2>3. Ветвления и циклы</h2></a>

Основные циклы, такие как `if` `for` `while` `switch` разобраны в [справочнике по Си](https://github.com/denismox/STM32HAL/blob/main/C%20lessons.md#cycle) и идентичны им и в С++

#### Цикл range-based for

Данный цикл позволяет перебрать все элементы контейнера (массива, вектора, списки, строки и некоторые пользовательские классы если они поддерживают нужный интерфейс)

Синтаксис выглядит следущим образом:

```
for(auto declaration : container){
    //loop body
}
```

`declaration` - переменная которая будет последовательно принимать значения элементов контейнера

`container` - обьект который можно обойти (array, vector, map, строка, initializer list и т.д.)

```
#include <iostream>
#include <string>

int main() {
    std::string line;
    std::getline(std::cin, line);
    for (char symbol : line) {
        std::cout << symbol << "\n";
    }
}
```

<a name="vector"><h2>4. Типы данных</h2></a>

Вектор `std::vector` и строка `std::string` - это базовые контейнеры стандартной библиотеки С++. Они хранят свои элементы в непрерывном фрагменте памяти. Оба этих элемента предоставляют доступ к элементам по индексу и позволяют эффективно добавлять элементы в конец

Вектор - это динамический массив который позволяет эффективно добавлять новые элементы в конец и при необходимости изменять свой размер. Вектор гарантирует отсутствие утечек памяти.

Элементы вектора должны быть одного типа и этот тип должен быть известен при компиляции 

`std::vector<int> vector_name` - вектор vector_name с элементами типа int 

`std::vector<std::string> vector_name` - вектор vector_name с элементами типа std::string

Пример программы которая заполняет вектор элементами и печатает их через пробел

```
#include <iostrem>
#include <vector>

int main(){
    std::vector<int> data = {1, 2, 3, 4, 5};
    for (int elem : data){
        std::cout << elem << " ";

    }
    return 0;
}
```

Здесь вектор инициализируется через список инициализации, в котором элементы перечислены через запятую. Другой способ инициализации вектора - указать число элементов и при необходимости образец элемента

```
std::vector<std::string> v1;                //пустой вектор
std::vector<std::string> v2(5);             //вектор из пяти пустых строк
std::vector<std::string> v3(5, "hello");    //вектор из пяти пустых строк hello
```

#### Обращение к элементам

В примере выше для работы с элементами массива использовался цикл range-for. Иногда удобнее работать с индексами. Вектор хранит элементы в памяти последовательно, поэтому по индексу элемента можно быстро найти его положение в памяти. Индексация начинается с нуля.



