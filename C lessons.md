# Справочник по C

## Содержание 

[1. Функции ввода/вывода](#IO)

[2. Математические функции ```<math.h>```](#math.h)

[3. Арифметические выражения в Си](#arithmetic)

[4. Представление памяти программы](#memory)

[5. Генерация случайных чисел в языке Си](#rand)

[6. Условные операторы](#operators)

[7. Функции и указатели](#functions)

[8. Символы. Структуры](#symbol)

[8. Циклы](#cycle)

[9. Массивы](#array)

[10. Адресная арифметика](#point)

[11. 2D массивы](#2D)

[12. Работа с файлами](#file)

[13. Строки](#string)

<a name="IO"><h2>1. Функции ввода/вывода</h2></a>

### Функция стандартного вывода

Для данных функций необходимо подключить библиотеку ```stdio.n```

```printf("<форматная строка>", <список вывода>);```

Например:

```
printf("A long time ago, in a galaxy far, far away...\n");
```

>A long time ago, in a galaxy far, far away...

```
printf("%d.%d.%d", 11, 12, 1990);
```

>	11.12.1990

### Функция стандартного ввода

`scanf("<Форматная строка>", <&Список ввода>);`

Так как `scanf` осуществляет запись введенного числа в память, то в качестве параметров ей передается не значение переменной, а ее __адрес__ (через взятие адреса __&__).

Например:

```
printf("Введите дату в формате <dd.mm.yyyy>:\n");
scanf_s("%d.%d.%d", &day, &month, &year);
printf("Ваша дата: %d/%d/%d", day, month, year);
```

>Введите дату в формате <dd.mm.yyyy>:
>
>09.08.2023
>
>Ваша дата: 09/08/2023

Функция `scanf` возвращает количество корректно разобранных format placeholder (это разные `%d` и прочие `%что-то`).

Таким образом мы можем узнать сколько правильно разобранных данных мы получили

```
#include <stdio.h>

#define R2 (5*5)

int main()
{
    int x, y;
    while(2 == scanf("%d%d", &x, &y)) {     // ПОКА прочитано два числа
        if (x*x + y*y > R2)
            printf("%d %d\n", x, y);
    }
    return 0;
}
```

### Символы-спецификаторы

Любая спецификация преобразования начинается знаком % и заканчивается символом спецификатором. Спецификаторы и соответствующие им аргументы должны быть согласованы по количеству и типам: в противном случае напечатано будет не то, что нужно.

![image](https://github.com/user-attachments/assets/86cfa23d-1c5d-43ca-a576-5706acdb181c)

#### Общий синтаксис спецификатора формата

`%[флаг][ширина][. точность][длина]спецификатор`

Таблица флагов

![image](https://github.com/user-attachments/assets/def5a1bc-d9e2-4d83-b2cf-bb42dc091225)

__Ширина__ - минимальная ширина поля. Если выводимое число меньше ширины, то оставшееся пространство будет заполнено нулями.

__Точность__ - максимальное количество печатаемых символов в строке, или количество цифр после десятичной точки для чисел с плавающей запятой, или минимальное количество цифр для целого.

__Длина__ - размер позволяет указать размер данных, переданных функции. h: для ввода значений типа short int (%hd). l: для ввода значений типа long int (%ld) или double (%lf, %le). L: для ввода значений типа long double (%Lf, %Le)

<a name="math.h"><h2>2. Математические функции ```<math.h>```</h2></a>


```abs(int num)``` Модуль от целочисленного числа

```fabs(double num)``` Модуль от вещественного числа

```ceil(double num)``` Округление до большего целого

```cos(double num)``` Косинус от аргумента num, num должен быть задан в радианах

```floor(double num)``` Округление до ближайшего меньшего цисла

```exp(double num)``` Возвращает значение экспоненты от аргумента num

```log(double num)``` Возвращает значение натурального логарифма от num

```log10(double num)``` Возвращает значение десятичного логарифма от num

```pow(double base, double x)``` Возведение в аргумента ```base``` в степень ```x```

```sin(double num)``` Синус от аргумента num, num должен быть в радианах

```sqrt(double num)``` Извлечение корня квадратного из аргумента num

```tan(double num)``` Тангенс от аргумента num, num должен быть в радианах

<a name="arithmetic"><h2>3. Арифметические выражения в Си</h2></a>

### Составной оператор присваивания

Составной оператор присваивания имеет следущий вид: 
```x <оператор>= b;```

```<оператор>``` это один из десяти операторов ```+ - * / % << >> & | ^```

Например ```x += dx``` ```p *= i```

### Приоритет и ассоциативность операций

Каждая операция имеет вполне определенный **приоритет** и **ассоциативность**.

**Приоритет** - формальное свойство оператора, влияющее на очередность его выполнения в выражении с несколькими различными операторами при отсутствии явного (при помощи скобок) указания на порядок вычисления.

**Ассоциативность** - свойство операций, которое определяет порядок их выполнения при равном приоритете. Бывает двух видов: Левая ассоциативность (вычисления происходят слева направо) и правая ассоциативность (вычисления происходят справа налево)

В языке Си арифметические операции имеют левую ассоциативность, а операции присваивания - правую ассоциативность.

Таблица приоритета

![image](https://github.com/user-attachments/assets/537a8401-e4ed-4712-947b-3ed1248064c9)

### Преобразование типов

Преобразование типов бывает неявное(автоматическое) и явное

#### Неявное преобразование

При преобразовании типов используется принцип ранжирования. При использовании в выражении операндов, имеющих разные ранги, операнд, имеющий меньший ранг, приводится к типу операнда с высшим рангом. Например, если один из операндов имеет тип *long*, а второй *double*, то первый операнд преобразовывается к типу *double*. Все короткие типы (short) преобразуются к типу int.

Таблица рангов типов

![image](https://github.com/user-attachments/assets/5e0e4dcf-e57c-42f5-9e96-ec8d3353eab0)

#### Явное преобразование

Явное преобразование типов выглядит следущим образом:

```(тип)выражение```

Например: ```res = (float) (x*y/5)``` или ```res = a / (float)b```

#### Преобразование типа при присваивании

При присванивании разных типов выполняется следущее правило: **тип значения выражения приводится к типу переменной**

Это может приводить к потере информации, например следущий код:

```
#include<stdio.h>

int main()
{
  short small = 1297;
  long big = 32538261;

  small = big;

  printf("%hd %ld", small, big);

  return 0;
}
```

Вернет:

```32405 32538261```


<a name="memory"><h2>4. Представление памяти программы</h2></a>

Память бывает трех видов:

1. __Статическая память__ - выделяется при запуске программы до вызова функции main из свободной оперативной памяти и используется для размещения глобальных и статических объектов (например глобальные переменные).

2. __Автоматическая память (стек)__ - резервируется при запуске программы до вызова функции main из свободной оперативной памяти и используется в дальнейшем для размещения локальных объектов, определяемых в теле функций, и агрументов функций в момент их вызова (тут лежат локальные переменные)

3. __Динамическая память__ - совокупность нескольких блоков, выделяемых из доступной свободной памяти непосредственно во время выполнения программы под размещение динамически создаваемых объектов

   ![image](https://github.com/user-attachments/assets/cbd6f36c-5bf0-407d-85cf-1eae56d89255)


<a name="rand"><h2>5. Генерация случайных чисел в языке Си</h2></a>

Функция `rand()` возвращает случайное целое число в диапазоне от нуля до _RAND_MAX_. Эта функция определена в заголовочном файле `stdlin.h`.

```#include "stdlib.h"```

```num1 = rand();```

Генерация псевдослучайных чисел обеспечивается начальным случайным числом или "зерном". Одно и то же начальное значение каждый раз будет генерировать одну и ту же последовательность. Чтобы этого не происходило необходимо каждый раз определять зерно новым числом. Это можно сделать при помощи функции `srand()`.

Функция `srand()` инициализирует генератор случайных чисел начальным числом. Например `srand(666);`.

Чтобы каждый раз было случайное число можно воспользоваться функцией `time();`

`srand(time(NULL))` Функция time(NULL) - возвращает количество секунд, прошедших с 1 января 1970 года (Unix-время).

#### Ограничение псевдослучайных чисел определенным диапазоном

Нижняя граница 0. Но ее можно понизить вичитая необходимое число:

`num = -10 + rand();

Верхнюю границу можно понизить путем взятия остатка от деления. Например `rand() % 11 может вернуть число от 0 до 10 так как остаток от деления на 11 не может быть больше 10.

Поэтому. Чтобы взять определенную границу, например (-10; 10) необходимо воспользоваться формулой:

```
int min = -10, max = 10;
int rand_number;

rand_number = min + rand() % (max - min + 1);
```

<a name="operators"><h2>6. Условные операторы</h2></a>

### Условный оператор if

В общем виде условный оператор имеет вид:

```
if (<условие>) {
       <действия>
} else if{
       <действия>
} else {
      <действия>
}
```

При этом есть и другие варианты написания условного оператора if


```
if (<условие>)
       <действиЕ>;
else if (<условие>)
       <действиЕ>;
else if (<условие>) {
       <действия>
} else
       <действиЕ>;

```

Или такой

```
if (<условие>) <действиЕ>;
else if (<условие>) <действиЕ>;
else if (<условие>) { <действиЯ> }
else <действиЕ>;
```

__Если после условия нужно одно действие, то не обязательно ставить блочный оператор ```{}```__

Иногда можно встретить запись следущего вида:

```
if(x){
  ...
}
```

Это проверка на истину. Если в скобках будет TRUE (т.е. не 0) то выполняется условие и действия внутри блочного оператора. Если FALSE (т.е. 0), то условие не выполняется. 

Порядок имеет значени. Если есть несколько условий удовлетворяющих блоку if ... else, то выполнится первое подходящее, остальные при этом выполнены не будут, например:

```
int x = 7;

if (x >= 8)
    printf("отлично");
else if (x >= 3)
    printf("удовлетворительно");
else if (x >= 5)
    printf("хорошо");
else
    printf("неудовлетворительно");
```

Данный код выведет _удовлетворительно_

#### Логические операторы

- ```&&``` - логическое __И__ (AND, конъюнкция)
- ```||``` - логическое __ИЛИ__ (OR, дизъюнкция)
- ```!``` - логическое отрицание (NOT) - превращает ложь в истину и наоборот

__Не путать:__ ```&&``` и ```||``` - это логические операторы, а ```&``` и ```|``` - побитовые.

### Тернарный оператор

Синтаксис оператора:

`<условие> ? <инстина> : <ложь>`

Если условие выполняется, то тернарный оператор возвращает _истину_, если не выполняется то возвращает <ложь>

Например:

```
int a = 2;
int b = 5;
int c = 10;

(a > b) ? c : -c;
```

>Программа вернет -10 (-c).

### Оператор множественного выбора switch

Синтаксис оператора:

```
switch (<переменная>){
 case <константа1>:
   <Операция1>;
   break;
 case <константа2>:
   <Операция2>;
   break;
...
 default:
   <Операция если ни один case не подошел>;
}
```

Значение _переменной_, указанной в условии switch сравнивается со значениями, которые следуют за словом case. Когда значение в переменной, соответствует значению в строке с оператором case, компьютер продолжит выполнение с _операции_ соответствующего кейса. 
Константы в case должны быть целочисленными (int, char и тд.)
Если не добавлять оператор break, то выполняются все действия с совпавшего case, те если совпал case3, то выполнятся все условия начиная с условия3.

Пример:

```
switch (n) {
 case 1:
    printf("Понедельник");
    break;
 case 2: 
    printf("Вторник");
    break;
 case 3: 
    printf("Среда");       
    break;
 case 4: 
    printf("Четверг");     
    break;
 case 5: 
    printf("Пятница");    
    break;
 case 6: 
    printf("Суббота");     
    break;
 case 7: 
    printf("Воскресенье"); 
    break;
 default: 
    printf("Неверный номер");
}
```
>При вводе n = 6 получим вывод:
>
>Суббота

Пример с выводом количества дней в месяце по номеру месяца:

```
switch(month) {
           case 1: case 3: case 5: case 7: case 8: case 10: case 12:
               printf("31\n");
               break;

           case 4: case 6: case 9: case 11:
               printf("30\n");
               break;

           case 2:
               printf("28\n");
               break;

           default:
               printf("Неверный номер месяца\n");
       }
```

<a name="functions"><h2>7. Функции и указатели</h2></a>

### Определение и вызов функции

Функция имеет следущий вид:

```
тип_возвращаемого_значения имя_функции(аргументы через запятую)
{
    тело функции
    return <что возвращаем>;
}
```
__имя_функции__ задает пользователь

__аргументы__ - _тип аргумента_ _имя аргумента_. У каждого аргумента должен быть прописан тип отдельно.

__тело функции__ - код, который выполняется во время вызова функции.

Оператор __return__ - возвращает значение из функции. _Выход из функции и вынос результата_.

__тип возвращаемого значения__ - тип того, что вернул оператор _return_. Если функция ничего не возврашает, то пишут тип _void_, в таком случае оператор _return_ можно не писать.

### Стандартные функции языка Си

Информация о стандартных функциях языка си содержится в 3-м томе справочника, например:

```man 3 sin```

![image](https://github.com/user-attachments/assets/921b1771-881a-4460-9966-be94c536368f)

### Прототип функции

Выше вызова фунции (выше функции _main_) должена быть реализация функции или ее прототип. Прототип позволяет объявить функцию, а ее реализацию прописать ниже функции _main_

Прототип получится если __тело функции__ заменить на __;__

```
float fahr(int cel);    // прототип

int main()
{
    float f;
    f = fahr(cel);      // вызов функции
    return 0;
}


float fahr(int cel)     // определение (реализация) функции
{
    return (cel * 1.8) + 32;
}
```

### Адреса и Указатели

Адрес - номер байта

Байт - самая маленькая единица памяти с адресом. Бит еще меньше, но адреса у него нет. В современных компьютерах как правило байт - это 8 бит.

Схематичное изображение памяти:

![image](https://github.com/user-attachments/assets/99efaf34-9db1-4384-b689-df2421718b08)

Предположим что переменная _х_ лежит по адресу 100 (т.е. занимает 4 байта: 100, 101, 102, 103), переменная _y_ по адресу 104, переменная _z_ по адресу 200.

Адреса - это числа. Их можно вычислять и хранить в переменных.

Оператор ```&``` называется оператором __взятия адреса__

Пусть переменная _x_ расположена по адресу 100 и ее значение 7:

```int x = 7; // Предположим что х расположена по адресу 100```

![image](https://github.com/user-attachments/assets/60f89485-f058-41f3-9cd5-ad50366325b9)

Сохраним этот адрес в переменную:

```
int x = 7;
int * px; // Объявили переменную px (pointer to x) типа int * (тип "Указатель на инт")
px = &x;
```

Таким образом px имеет тип _int *_ и значение _100_

![image](https://github.com/user-attachments/assets/862afa30-8c36-4e63-8fc2-ccfc63fc97a1)

Оператор ```*``` - это оператор разыменования. Оператор ```*``` обратный оператору ```&```. ```*``` по адресу находит значение, которое там записано.

Он позволяет работать с самими данными вместо адреса

```int y = *px + 3;```

_px_ имеет тип _int *_ и значение 100. Это __адрес данных__

_*px_ имеет тип _int_. Чтобы вычислить значение _*px_ нужно перейти по адресу 100, взять байты в которых храниться переменная px (100, 101, 102, 103) и прочитать число, лежащее в этих байтах, как int. __Получим число 7__, те __сами данные__.

Таким образом ```y = 10```

Для печати адреса используется формат ```%p```. Адрес печатается в шестнадцатиричном формате. 

В языке Си нельзя возвращать несколько значений переменных, поэтому если необходимо изменить несколько переменных за один вызов функции, то необходимо использовать адреса и указатели. Например как в функции ```scanf()```. 

Пример:

```
#include "stdio.h"

void min2time(int mm, int *h, int *m);

int main()
{
    int mm, h, m;
    scanf("%d", &mm);
    man2time(mm, &h, &m);
    printf("%02d:%02d", h, m);
    return 0;
}

void min2time(int mm, int *h, int *m)
{
    mm %= 1440;
    *h = mm / 60;
    *m = mm % 60;
}
```

В данном коде за один вызов функции min2time при помощи указателей изменяем значение переменных _h_ и _m_.

Указатель с двумя звездами - это указатель на указатель на ..., например ```int *px = &x; int **ppx = &px;```

Нельзя присваивать адрес указателю, если у них различаются типы данных. Тк могут несовпадать количество бай у этих типов.

```void *``` - это тип "просто адрес". такой тип нельзя разыменовывать, но к нему неявно или явно приводится любой тип.

```
int x = 7;
int *px = &x;
void *y = px;  //неявное приведения типа int* к void*
//или явное преобразование
*(int *)y
```

### Оператор sizeof

Оператор ```sizeof``` дает размер переменной или типа в байтах

Результат имеет тип ```size_t```

Чтобы напечатать результат этого оператора нужно использовать спецификатор ```%zu```

```printf("%zu", sizeof(*int));```

Все типы указателей имеют одинаковый размер:

```
/*Они все имеют одинаковый размер*/
sizeof(*int);
sizeof(*char); 
sizeof(*double);
sizeof(**int);
...
```

Любой указатель должен быть инициализирован, если нет понимания чем, то можно использовать NULL

```int *p = NULL;```

Размер типов данных зависит от системы. Размер char всегда 1 байт.

```
int x;
printf("%zu\n", sizeof x);      // 4 в моей системе и на repl.it
printf("%zu\n", sizeof(1 + 2)); // 4 в моей системе и на repl.it
printf("%zu\n", sizeof 3.5);    // 8 в моей системе и на repl.it
printf("%zu\n", sizeof(char));  // 1 всегда
```

##### Sizeof и массивы

```
int a[5];
size_t n = sizeof(a);        // 20. Так как 20 = 4 * 5, а sizeof(int) = 4
```

Также можно перебрать все элементы массива

```
int a[] = {7, -12, 34, 2};
for(int i = 0; i < sizeof(a) / sizeof(a[0]); i++){
    //Делаем что-то с a[i]
}
```

- sizeof(a) - размер всего массива в байтах
- sizeof(a[0]) - размер нулевого элемента в байтах
- sizeof(a) / sizeof(a[0]) - размер всего массива в байтах

##### Sizeof и структуры

```
struct A {
    int x;
    char c;
    double d;
} z;
```

sizeof(int)+sizeof(char)+sizeof(double) ≤ sizeof(struct A) из-за выравнивания данных. Числа при хранении выравниваются по машинным словам. При этом образуются "дырки", которые не заняты данными.

### Глобальные переменные

__Глобальные переменные__ - это такие переменные, время жизни которых распротраняется на всю программу. Декларируются такие переменные вне функций. Область видимости от декларации до конца файла. 

Область видимости можно расширить при помощи ```extern```, поэтому глобальные переменные принято объявлять до объявления каких-либо функций

__НАЧАЛЬНОЕ ЗНАЧЕНИЕ ГЛОБАЛЬНЫХ ПЕРЕМЕННЫХ ПО УМОЛЧАНИЮ 0! (в отличии от локальных в которых будет лежать мусор)__

Вне функций нельзя делать действий с переменными, только объявлять.

```
#include <stdio.h>

int x = 5;  // это глобальная переменная х

void foo() {
    x = x + 1;
}

int main() {
    foo();
    foo();
    printf("x=%d\n", x);
    return 0;
}
```

### Переменные static

У статических переменных - время жизни распространяется до конца программы (как и у глобальных). Но область видимости ограничена.

Такие переменные объявляются с ключевым словом __static__

```static int x;```

Область видимости: весь файл от декларации, если объявлена вне функций, или внутри функции или блока если объявлена внутри функции или блока.

Область видимости нельзя расширить на другие файлы

__Начальное значение по умолчанию 0__

Инициализируются один раз.

Так как область видимости ограничена, то можно объявить разные статические переменные с одним и тем же именем в разных областях видимости.

### #define

В самом начале текст программы обрабатывается препроцессором. Он делает поиск текста и его замену.

![image](https://github.com/user-attachments/assets/8ae10c8e-4753-4b1c-b33f-ae32f2d5c39a)

Директивы препроцессора начинаются с ```#```. В конце директив не ставится ```;```

```#include <имя_файла>``` заменяет эту строку на содержимое файла _имя_файла_

```#define идетификатор текстовая_замена``` Заменяет идентификатор на все содержимое до конца строки - это называется __макроподстановка__ или __макрос__

```
#define A 3;    // поставили ; в конце
x = A + x;      // заменилось на x = 3; + x; - ошибка компиляции
```

Макросы могут быть с аргументами:

```
#define cube(x) x*x*x
y = cube(2) //y = 2*2*2
```

Чтобы небыло ошибок при использовании макроса нужно ставить скобки около каждого аргумента и около всего макроса:

```
#define cube(x) ((x)*(x)*(x))
```

Также при вызове макроса лучше не использовать __++__ или __--__. Для таких задач лучше использовать функции.

Также не стоит вызывать функции в макросах

### Условная компиляция

Макросы также позволяют выполнять только определенную часть кода, например:

```
#define AAA
#ifdef AAA
  //Часть кода, которая выполняется если определен макрос ААА (у нас определен)
#elif BBB
  //Часть кода, которая выполняется если определен макрос BBB (у нас не определен)
#else
  //Часть кода, которая выполняется если не определены остальные макросы
#endif
```

Можно не определять макрос ААА в коде программы, а указать его при компиляции в системе:

```gcc -DAAA hello.c```

ключ ```-D``` с аргументом ```AAA``` работает как ```#define AAA```

Полная и кратка форма макросов:

```
#ifdef BBB          // краткая форма
#if defined BBB     // полная форма
#if defined (BBB)   // полная форма

#ifndef BBB          // краткая форма
#if !defined BBB     // полная форма
#if !defined (BBB)   // полная форма
```

Можно отменить объявление макроса при помощи ```#undef AAA```

Существует 2 операции которые может выполнять препроцессор: __#__ и __##__

__#__ - заключает текст параметра в кавычки

__##__  - Позволяет объединить две лексемы

Тут "склеиваются" 3 числа

```
#include <stdio.h>
#define print(a,b,c) printf("%d", a##b##c);
 
int main(void)
{
    print(2, 81, 34);   // 28134
    return 0;
}
```

<a name="symbol"><h2>8. Символы. Структуры</h2></a>

### Символы

#### ASCII таблица

![image](https://github.com/user-attachments/assets/1974014e-c0d8-45aa-92a5-3be7b911f54a)

Коды символов как правило хранят в типе ```char``` размером 1 байт.

Чтобы не запоминать численное значение символа ввели понятие __символьная константа__. Она пишется в одинарных кавычках и обозначает код символа. Тип символьной константы __int__.

```'a' // значение: 97```

#### Чтение и печать одного символа

Для чтения с помощью ```scanf``` и печати ```printf``` используют форматный спецификатор __%c__

```
char x;
scanf("%c", &x);                            // нажмем на клавиатуре клавишу Q и далее Enter
printf("символ %c, ASCII код %d\n", x, x);  // символ Q, ASCII код 81
```

Есть специальные функции ```getchar``` и ```putchar```, которые читают и печатают один символ

```
int x;          // да, именно int
x = getchar();  // нажмем на клавиатуре клавишу Q и далее Enter
putchar(x);     // Q
```

Тип __int__ нужен для проверки на ошибку (только в getchar в scanf можно использовать char, так как в функциях с переменным числом аргументов любой целый тип, меньший _int_, будет неявно преобразован е _int_). Если символ пришел верно, то в старших байтах нули, а в младших число соответствующее ASCII-символу. В случае ошибки все биты станут равны 1 и функция вернет -1. Если использовать ```char x = getchar();``` то в случае ошибки в x будет число 255, что в некоторых кодировках совпадает с символом ```Ъ```

Чтобы получить из символа цифры эту же цифру нужно вычесть из сивольной константы ```'0'``` так как все символы идут по порядку начиная с нуля в ASCII.

```
char x = '3'
char y = '0' - x;  //y = 3;
```

Если изнальный тип переменной, в которую мы хотим записать значение при помощи ```scanf```, ```char```, то и записывать нужно со спецификатором _%hhd_ или _%c_, иначе в случае _int_ ASCII-код можно код будет записан в байт с наименьшим адресом (а старший или младший это байт зависит от архитектуры).

### Структуры

Структуры - это определяемый пользователем тип, который содержит данные, возможно разных типов

Структура состоит из полей. Каждое поле имеет __тип__ и __имя__.

```
struct Student {
  long id;
  int birth_year;
  float weight;
  float height;
  float run100;
  unsigned char pushup;
  unsigned char pullup;   // пишем поля
};                        // ; <== обязательно
```

Содержание:
1) Ключевое слово struct (нельзя опустить)
2) Student - имя структуры (принято писать с большой буквы);
3) Поля пишут в фигурных скобках ```{}```
4) Поля определяют как ```<тип> <идентификатор>``` (```long id;```). Поля могут быть разных типов.
5) __После объявления структуры обязательно ставить ;__

#### Объявление переменной:

С неявной идентификацией:

```
struct Student gusev;
```

С явной идентификацией:

```
struct Student ivanov = {321456, 2000, 70.4, 1.86, 17.6, 14, 5};
```

__Поля при явной идентификацией пишут в том же порядке что и при объявлении структуры.__

Можно инициализировать только часть полей:

```
struct Student petrov = {312456, 1999};    //только id и birth_year, остальные поля 0;
```

Чтобы при инициализации перечислять данные в любом порядке нужно указывать имя поля

```
struct Student sidorov = {.weight = 56.6, .height = 1.62, .id=345789};
```

При этом нельзя присваивать к уже созданной переменной анонимную структуру. Только при инициализации или при помощи приведения к типу ```struct Student```

```
struct Student zotov;         // ок
zotov = {198345, 2001, 61.9}; // ошбика
```

Правильно:

```
struct Student zotov;
zotov = (struct Student){198345, 2001, 61.9};  // ok
```

#### Копирование структуры

__Оператор ```=``` копирует структуры одинакового типа__

```zotov = sidorov``` //sidorov типа struct Student, как и zotov

__Нельзя копировать структуры разных типов, даже если у них одинаковые типы и количество полей__

```
struct Fruit {
    int price;    // рубли
    float weight; // кг
};
struct Human {
    int age;      // возраст, полных лет
    float height; // рост, метры
};


// полтора килограмма по 200 рублей за килограмм
struct Fruit apple = {.price = 200, .weight = 1.5};
struct Human vasya;
vasya = apple;                                      // Ошибка
vasya = (struct Human){18, 1.76};                   // ok
vasya = (struct Human){.age = 18, .height = 1.76};  // Ошибка
```

Здесь ```{18, 1.76}``` - экземпляр Анонимной структуры, поэтому нельзя присать ```{.age = 18, .height = 1.76};```, так как поля ```.age``` и ```.height``` относятся к ```struct Human```, а не к анонимной структуре.

#### Использование переменных

__Переменная.поле__ - обращение к полю переменной через оператор "точка"

```
struct Student zotov;
zotov.height = 1.72;
zotov.pullup = 9;


zotov.id = sidorov.id + 2;


printf("Самый высокий рост: %.2f\n", ivanov.height);


scanf("%d", &zotov.id); // скобки не нужны, приоритет . больше, чем приоритет &
```

#### Адрес структуры

В функцию можно также передавать адрес структуры, а не копию ее полей, и работать с адресами. Например:

```
void inc(struct Point *p){
(*p).x = (*p).x + 1;
}
```

Для удобства в Си есть оператор доступа к полю структуры ```->```

```
void inc(struct Point *p);

int main()
{
   struct Point t;
   t.x = 2;
   inc(&t);
   inc(&t);
   printf("%d\n", t.x);


   return 0;
}

void inc(struct Point * p)
{
    p->x = p->x + 1;
}
```

#### typedef

Для любого типа можно определить новое имя с помощью __typedef__:

```typedef <существующий тип> <псевдоним>```

```
typedef unsigned char Age;              // тип для хранения возраста человека в годах
typedef unsigned long long int llu;     // просто надоело писать длинные слова

unsigned char x;
Age student = 17;


llu z = (llu)x * x;
unsigned long long *p = &z;
```

- Псевдоним можно использовать там же, где используется тип.
- Можно использовать как псевдоним, так и исходный тип.
- Псевдоним - одно слово.
- Псевдоним принято писать с большой буквы (кроме низкоуровневых - ```llu``` и кроме системных - ```size_t```)
- Псевдониму нельзя дать системное имя (int, for, return и тд).

При помощи typedef можно не писать каждый раз слово struct

```
struct Point{
  int x;
  int y;
};
typedef struct Point Point;
```

То же самое, но можно соединить определение структуры с typedef:

```
typedef struct Point {
  int x;
  int y;
} Point;
```

#### Анонимные структуры

Можно определять структуры без указания имени. Такие структуры называеются анонимными.

Можно определить структуру, переменные и дальше их использовать.

```
struct {
  unsigned char age;
  float weight;
} man, woman, cat;

cat.age = 2;
cat.weight = 4.7;
```

Однако ананимные структуры не могут быть типом формального аргумента функции:

```int is_adult(struct p);  //ошибка. не существует тип struct```

Но если использовать псевдони при объявлении структуры, то можно использовать анонимную структуру везде где используем этот тип. Это сокращает запиcь:

```
typedef struct {
  int hour;
  int minute;
  int second;
} Time;

Time clock = {12, 34, 5};

int time2min(Time t);
Time man2time(int mm);
```

<a name="cycle"><h2>9. Циклы</h2></a>

### Цикл While

Оператор _while_ выполняет тело цикла если условие цикла истинно, затем опять проверяет условие, если условие ложно - передает управление на первый оператор за циклом.

```
while (условие продолжения цикла){
    тело цикла
}
```

Если в теле цикла одна строка, то ```{}``` можно не ставить. 

Также в цикле может быть несколько условий (по аналогии с _if_)

```
while (k > 0 && b = 1){
    тело цикла
}
```

#### Оператор do ... while

В операторе _while_ сначала проверяется условие, а потом выполняется тело цикла. В Операторе _do ... while_ сперва выполняется тело цикла, а хатем проверяется условие продолжение цикла.

```
do {
  тело цикла;
} while(условие продолжения цикла);
```

Этот цикл используется когда необходимо чтобы условие выполнилось хотябы один раз.

### Цикл for

Цикл _for_ имеет следущий вид:

```
for(выражение1; выражение2; выражение){
  Тело цикла;
}
```

_выражение1_ - это инициализация, выполняется один раз в начале цикла. Можно инициализировать несколько переменных через запятую ```for(int i = 0, double y = 2; ... ; ...)```

_выражение2_ - условие продолжения цикла. Условие может быть сложным. Без запятых, только логические операторы `&&`, `||`, `!`.

_выражение3_ - выполняется каждый раз после выполнения тела цикла. Может быть несколько операций через запятую `for(... ; ... ; i++, res += 10)`

В цикле _for_ можно пропустить любое из выражений.

```
for(;;)  //бесконечный цикл
  printf("Hello, world\n"); 
```

### break, continue, goto

Оператор `break;` - завершает работу текущего цикла или _switch_.

```
#include <stdio.h>

int main()
{
    int x;          // яблок на одной (текущей) яблоне
    int sum;        // уже собрали яблок
    int n;          // количество деревьев
    int i;          // сколько деревьев уже обработали

    scanf("%d", &n);

    sum = 0;        // не забыть очистить корзину перед сбором яблок!
    for(i= 0; i < n; i++) {
        scanf("%d", &x);
        if (x < 0) {                // если ВОРОНЫ
            printf("ВОРОНЫ!\n");
            break;                  // убегаем из ряда
        }
        sum += x;
        printf("i=%d x=%d sum=%d\n", i, x, sum);
    }
    // сюда передаст управление break
    printf("%d\n", sum);
    return 0;
}
```

Оператор `continue;` - управление передается на следущую итерацию цикла.

```
#include <stdio.h>

int main()
{
    int x;          // яблок на одной (текущей) яблоне
    int sum;        // уже собрали яблок
    int n;          // количество деревьев
    int i;          // сколько деревьев уже обработали

    scanf("%d", &n);

    sum = 0;        // не забыть очистить корзину перед сбором яблок!
    for(i= 0; i < n; i++) {         //сюда попадет программа после continue (начнет с i++)
        scanf("%d", &x);
        if (x < 0) {                // если ВОРОНЫ
            printf("ВОРОНЫ!\n");
            continue;               // идем к следующей яблоне
        }
                                    // этот код тоже не выполняется при continue
        sum += x;
        printf("i=%d x=%d sum=%d\n", i, x, sum);
    }
    printf("%d\n", sum);
    return 0;
}
```

Оператор `goto МЕТКА;` позволяет переходит к МЕТКЕ выше или ниже по коду. Метка ставиться `МЕТКА:`

- Все метки должны иметь разные имена
- Разные `goto` могут вести к одной метке
- `goto` не может передать управление вне функции. Тоесть метка и переход на нее должны находится в одной функции.

Оператор `goto` понижает читаемость кода. Его следует использовать как аналог к операторам `break` и `continue` во вложенных циклах.

Пример использования `goto`:

__goto L;__ - `break` по внешнему циклу. Управление передается сразу за циклом (после `}`)
__goto K;__ - `continue` по внешнему циклу. Управление передается на `j++`

```
int main()
{
A:  
    int rows, j, total, n, i, x, sum;
B:  
    scanf("%d", &rows);
    total = 0;
C:  
    for (j = 0; j < rows; j++) {
D:
        scanf("%d", &n);
        sum = 0;        // не забыть очистить корзину перед сбором яблок!
E:
        for(i= 0; i < n; i++) {
F:          
            scanf("%d", &x);
            if (x < 0)
                goto ???;       // куда переходить?
            sum += x;
            printf("j=%d i=%d x=%d sum=%d\n", j, i, x, sum);
G:          
        }
H:      
        total += sum;
        printf("j=%d total=%d\n", j, total);
K:      
    }   
L:  
    printf("%d\n", total);
M:  
    return 0;
}
```

<a name="array"><h2>9. Массивы</h2></a>

Массив - это набор однотипных элементов фиксированной длины

- Массив состоит из элементов
- Все элементы одного типа
- Размер массива не меняется после его создания

У каждого элемента есть свой номер (индекс). В языке Си все инждексы начинаются с 0.

![image](https://github.com/user-attachments/assets/d72b97d2-7d54-4205-b792-0a9870bee671)

Объявление массива:

```
int a[10];          // массив с именем a из 10 элементов, каждый элемент типа int
float b[5];         // массив b из 5 элементов типа float
struct Point tr[3]; // массив tr из 3 элементов типа struct Point
```

Элемент массива можно прочитать и записать:

```
a[0] = a[3] - 17;   // элемент массива можно прочитать, в него можно записать.
```

#### Явная и неявная инициализация массива:

Объявление массива без инициализации:

```
int a[7];  // или "мусор" (локальный), или нули (глобальный, static)
```

Можно инициализировать все элементы массива или часть из них (тогда остальные будут равны нулю)

```
int a1[3] = {12, -6, 44};   // a1[0] = 12, a1[1] = -6, a1[2] = 44;
int a2[3] = {12, -6};       // a2[0] = 12, a2[1] = -6, a2[2] = 0; оставшиеся нули
int a3[3] = {12, -6, 44, 8};       // Ошибка, чисел больше, чем размер массива
```

Размер массива можно не указывать при явной инициализации, тогда размер массива будет равен количеству заданных элементов.

```
int a6[] = {12, -6, 44};    // int a6[3] = {12, -6, 44};
```

Начиная с С99 можно указывать какие именно элементы массива нужно проинициализировать

```
int a[10] = {[1] = 12, [4] = -3};        //a[1] = 12, a[4] = -3, остальные нули
```

<a name="point"><h2>10. Адресаня арифметика</h2></a>

### Чем массив отличается от указателя

```
int a[5];    //массив из 5 int
int * pa;    //указатель на int (пока никуда не указывет)

pa = &a[0];  //pa указывает на начало массива
pa = a;      //pa указывает на начало массива
```

Когда говорят об указателе на массив, говорят об указателе на первый элемент массива `&a[0]`

__Имя массива содержит адрес его начала__. Поэтому можно писать `pa = a`

Массив это не только адрес и тип элемента, но и их количество. `pa` может указывать не только на начало массива, но и на любой его элемент.

### Адреса элементов массива

![image](https://github.com/user-attachments/assets/2a2979f0-7104-43cd-802c-196f97b1b551)

Пусть массив начинается с адреса 100, тогда адреса его элементов 100, 104, 108, 112 и 116.

```
int a[5];   // массив из 5 int
int * p0;   // еще один указатель (никуда не указывает)
int * p3;   // еще один указатель (никуда не указывает)


p0 = &a[0]; // p0 указывает на a[0]
p3 = &a[3]; // p3 указывает на a[3]


printf("p0=%p p3=%p \n", p0, p3);   // проверим адреса(%p)
```

Как из `p0` получить `p3`? Нужно из адреса 100 получить адрес 112, это `100 + 3 * 4`, то есть `p0 + 3*sizqof(int)`

Однако в СИ есть __адресная арифметика__. Если одно слагаемое указатель, а другое целого типа, то результат указатель.

Поэтому можно писать:

```
p0 = a;            // имя массива содержит его начало, a[0]
p3 = p0 + 3;       // p3 указывает на 3 элемент массива, a[3]

printf("p0=%p p3=%p", p0, p3);    //адреса остались прежними
```

Так как `p0` типа указатель на int, то сдвигаемся на 3 int.

```
double z[10];
double *pz = z;    // pz указывает на начало массива z
```

`pz + 2` - сдвинуться на 2 `double` 

### [] и операции с указателями

```
int a[5] = {2, -4, -5, 11, 27}
int *p = a;
```

Как записать число 7 в первый элемент массива?

```
a[0] = 7;    //через массив
*p = 7;      //через указатель
```

Заменить число 11 на 88 в массиве можно так:

```
a[3] = 88;        //через массив
*(p + 3) = 88;    //Указатель на массив сдвинули на 3 элемента и разыменовали. Так как в скобках указатель плюс целое, то получаем указатель + 3(sizeof(тип на который указывает указатель))
```

__Оператор [] придуман для удобства записи. `a[b]` идентично `*(a + b)`__

`scanf` тоже можно записать с помощью адресной арифметики.

```
scanf("%d", &a[3]);    // через []
scanf("%d", a + 3);    // меняем [] на &*(a + 3) при этом &* сокращаются до a + 3
```

Поэтому все выражения синтаксически корректны:

```
*(3 + a) = 88;             //так как *(3 + a) == *(a + 3)
3[a] = 88;                 //так как 3[a] эквивалентно *(3 + a)
char c = "abcdefgh"[2];    //строка - это массив символов с символом '\0'
```

### когда работают правила адресной арифметики

- __указатель + целое = указатель__
- __указатель - указатель = целое__
  - указатели должны быть одинакового типа
  - целое - сколько __элементов__ укладывается между этими адресами
- Указатель + указатель = ошибка (нет смысла складывать указатели)

__Сравнение указателей__

- указатель1 == указатель2
- указатель1 != указатель2

Эти сравнения машинно-зависимы:

- указатель1 < указатель2
- указатель1 > указатель2

Надо сравнивать так:

- указатель1 - указатель2 < 0
- указатель1 - указатель2 > 0

### void *

Иногда нужен "просто адрес" без уточнения типа. Например в стандартных функциях нужно уметь работать с разными типами данных, поэтому в функциях нужен просто адрес

"Просто адрес" имеет тип `void *` __указатель на void__

`void *pv;`

- С `void*` __не работает адресная арифметика__ (pv + 3 - нельзя сдвинуть на 3 элемента типа void, неизвестен размер)
- Нельзя разыменовывать
- `*pv` не работает, нет данных типа void
- `pv->` не работает, потому что это `(*pv).`
- `pv[i]` не работает, потому что это `(*(pv + i))`

__Неявные преобразования указателей к/из void*__

```
int x;
char c;
double z;


int * px = &x;
char * pc = &c;
double * pz = &z;


void * pv;  // указатель типа void*


pv = px;    // неявное преобразование int* в void*
px = pv;    // неявное преобразование из void* в int *


pv = pc;    // из char* в void*
pc = pv;    // из void* в char*


pv = pz;    // из double* в void*
pz = pv;    // из void* в double*
```

#### NULL - адрес, которого не существует

По определению, стандартная константа NULL - это адрес, которого не существует

Обычно `NULL` это `(void*)0` (приведение 0 к типу void*)

Нельзя писать по этому адресу. Нельзя читать по этому адресу.

Это работает:

```
int y, x = 7;
int * p = &x;   // p указывает на x
y = *p;         // y = 7;
*p = 22;        // x = 22;
```

Это не работает:

```
p = NULL;       // p указывает на несуществующий адрес
y = *p;         // Ошибка, нельзя читать по адресу NULL
*p = 22;        // Ошибка, нельзя писать по адресу NULL
```

### Копирование массива

В си массиву нельзя ничего присвоить (не путать с элементом массива, ему можно)

```
int a[5];
int b[5];
a = b;        // ошибка. Нельзя присваивать массиву.
```

Поэтому для работы с массивами можно использовать стандартные функции из файла `string.h`

__memcpy__

Прототип функции memcpy: `void *memcpy(void *dest, const void *src, size_t n);`

- dest - куда копировать
- src - откуда копировать
- n - размер в __байтах__

Использование:

```
int a[10] = {1, -2, 3, -4, 5, -6, 7, -8, 9, 10};
int b[10];
memcpy(b, a, sizeof(a));
```

__memcpy нельзя использовать на перекрывающихся участках памяти.__ Тоесть нельзя скопировать элементы 2-5 массива _a_ в элементы 4-7.

Для копирования перекрывающихся участков памяти следует использовать функцию `memmove`

Прототип функции: `void *memmove(void *dest, const void *src, size_t n);`

Делает тоже, что и функция `memcpy`, но для копирования создает буфер, который позволяет копировать перекрывающиеся участки памяти.

__memset__

Записывает младший байт числа __c__ в каждый байт на участке памяти размером __n__, начиная с адреса __s__.

Прототип функции: `void *memset(void *s, int c, size_t n);`

Заполнение массива b нулями

```
memset(b, 0, sizeof(b));
```

При передачи массива в функцию, он передается как указатель.

<a name="2D"><h2>11. 2D массивы</h2></a>

Многомерные массивы принято заполнять так же как матрицы: сначала записывать номер строки (row), затем номер столбца (column)

![image](https://github.com/user-attachments/assets/ae455e8b-7b73-4f09-b49f-e9cbb248b1fe) ![image](https://github.com/user-attachments/assets/05c1e52d-25cb-46f4-9b05-6adbfae3990c)

Обьявление и инициализация массива 3*4:

![image](https://github.com/user-attachments/assets/699b823d-2545-4575-8fdd-c719cbede606)

```
int matrix[3][4] = {
    {1, 2, 3, 4},
    {11, 12, 13, 14},
    {21, 22, 23, 24}
};
```

К одному элементу массива обращаемся `a[i][j]`

Массив хранится единым участком памяти и в языке Си размещается в памяти так:

![image](https://github.com/user-attachments/assets/922bd515-8125-4fa5-a81b-1cc82e3a2bc3)

Эффективный код для обработки всех элементов массива:

```
int sum = 0;
for(int i = 0; i < 3; i++){
    for(int j = 0; j < 4; j++){
        sum += a[i][j];
        printf("%d", sum);
    }
}
```

`i` - индекс по строкам массива, `j` - индекс по столбцам массива.

### Передаем массив в функцию

При передаче массива в функцию, в нее передается указатель на первый элемент массива

Функция, принимающая одномерный массив int может быть определена так:

```
void f1(int b[3]);        //размер массива игнорируется
void f2(int b[]);         //размер можно не указывать
void f3(int *b);          //на самом деле функция принимает указатель на int (а не на массив)
```

__Все три декларации эквивалентны__ и объявляют функцию, принимающую указатель на int

Параметр `b` во всех трех случаях имеет фактический тип `int *`. Размер массива и сам факт наличия одномерного массива потерян.

Поэтому `sizeof(b)` равен не размеру массива, а размеру указателя. Тоесть невозможно посчитать количество элементов массива переданного в функцию через `sizeof(b) / sizeof(b[0])`

Также в случае многомерного массива тоже передается указатель на первый элемент массива и `sizeof` от переданного массива тоже будет равен размеру указателя.

![image](https://github.com/user-attachments/assets/e17c63a3-4c29-41b5-a100-f4f32a00c8ec)

Тоесть в случае с двумерным массивом в фукнкцию придет указатель на массив из 4 целых чисел (int (*a)[4]). Тоесть многомерный массив это абстракция, по сути это массив из массивов из массивов и тд.

Поэтому, по аналогии с передачей одномерного массива в функцию игнорируется размерность этого массива также и с двумерным массивом будет игнорироваться количество первой размерности (игнорируется количество строк, учитывается только количество столбцов)

Таким образом, эти три обьявления функции эквиваленты:

```
void f1(int a[3][4]);        // Указав все размерности массива, первая размерность игнорируется
void f2(int a[][4]);         // Указав все размерности кроме первой
void f3(int (*a)[4]);        // Определив параметр как указатель на массив из 4 int
?void f4(int *((*a) + 4))    // Верно ли это?
```

<a name="file"><h2>12. Работа с файлами</h2></a>

### Потоки данных

Поток данных это некоторая абстракция которая производит или потребляет информацию.

В ОС информация о потоках данных хранится в таблице файловых дескрипторов. Индекс эелемента этого массива - это некоторое целое неотрицательное число - называется файловым дескриптором.

![image](https://github.com/user-attachments/assets/c4f1b3de-2629-412c-ada9-34e5746440cd)

С потоками работают стандартные функции языка С `scanf` `printf` `fread` `fwrite` и другие

С файловыми дескрипторами работают системные вызовы ОС `read` `write` и прочие

### Перенаправление потоков

Перенаправление нужно чтобы переместить выходной поток в другое место

![image](https://github.com/user-attachments/assets/ac1c5dfd-9df5-469d-b815-2de3ffc71964)

### fopen открытие файла

Открываем файл и выводим результат работы в другой файл

```
#include <stdio.h>


int main()
{
    FILE * fin  = fopen("data.txt", "r");   // открыть файл data.txt на чтение - поток fin
    FILE * fout = fopen("out.txt", "w");    // открыть файл out.txt на запись - поток fout


    int n;
    fscanf(fin, "%d", &n);                  // читаем количество чисел из потока fin


    int i, sum;
    for(sum = 0, i = 0; i < n; i++) {
        int x;
        fscanf(fin, "%d", &x);              // читаем очередное число из потока fin
        sum += x;
        printf("i=%d x=%d sum=%d\n", i, x, sum);    // отладочная печать в поток stdout
    }


    fprintf(fout, "%d\n", sum);             // результат пишем в поток fout


    fclose(fin);                            // закрываем открытые нами потоки
    fclose(fout);


    return 0;
}
```

<a name="string"><h2>13. Строки</h2></a>

__Строка__ - это последовательность символов, оканчивающихся символом `'\0'`

В языке C нет специального типа для работы со строками. Для этого используются массивы с элементами типа `char` и указатели `char *`

```
char a[10] = {'a', 'b', '\0'}    //Массив символьных констант
char * a2 = "hello";             //Строковая константа
```

__Символьная__ (или литеральная) константа в языке СИ - это один сомвол, заключенный в одинарные кавычки. Например `q` или `0`. Она имеет ти __int__ и значение согласно ASCII коду.

__Строковая константа__ - это нуль или более символов в __двойных кавычках__. Имеет тип const char *.

### Массивы с элементами типа char

Это одинаковые массивы из 6 элементов:

```
char b1[6] = {'w', 'o', 'r', 'l', 'd', '\0'};
char b2[] = {'w', 'o', 'r', 'l', 'd', '\0'};     //Размер массива можно не указывать он вычисляется автоматически
char b3[] = "world";                             //Стандарт позволяет писать строковую константу для инициализации каждого элемента массива
```

Массивы b1, b2, b3 хранятся в памяти одинаково - единым куском памяти.
![image](https://github.com/user-attachments/assets/f39e4f58-ec1f-4001-9da8-7180b4d6f89c)

### Массив или указатель

Эти строки хранятся в памяти по-разному:

```
char s1[] = "world"     //Массив из 6 символов
char * s2 = "world"     // 1 указатель на char, указывает на строковую константу "world"
```

![image](https://github.com/user-attachments/assets/14182b1c-aec1-4565-9a6e-85a7869afe2e)

`sizeof(s1) == 6`

`sizeof(s2) == sizeof(void *)` равен размеру адреса

Строковая константа хранится в read-only области памяти, ее нельзя изменять

```
s1[0] = 'H';    //Заменит в массиве первый символ на H
s2[0] = 'W';    //Программа упадет, так как нельзя писать в read-only область памяти
```

### Как сравнивать строки

Нельзя сравнивать так: `s1 == s2` так идет сравнение адресов

Для сравнения строк используют функции `strcmp` и `strncmp`.

`strcmp` - стандартная функция которая сравнивает две строки и возвращает 0 если символы одной строки равны символам другой строки

```
char b1[] = "world";
char b2[] = "world";
char *p = b1; 

if(b1 == b2)               // false b1 и b2 - это два разных адреса

if(0 == strcmp(b1, b2))    // true строки одинаковые, значит strcmp вернет 0

if(p == b1)                // true эти адреса равны
```

### Чтение и печать строк

#### Печать строк

Печатать строку можно при помощи __printf__ по формату __%s__ (string). Печатаются все символы до символа '\0', сам символ '\0' не печатается.

```
char a[] = "hello";
char *s = "world";

printf("%s\n", a);        //hello
printf("%s\n", s);        //world

printf("%s\n", a + 1);    //ello
printf("%s\n", s + 1);    //orld
```

Также можно печатать строку с помощью функции __fputs__

```
fputs("Hello, world!\n", stdout);
```

#### Чтение строки

Чтобы прочитать строку память для нее уже должна быть выделена. Тоесть должен быть заранее объявлен массив подходящей длины, либо выделена динамическая память.

```
char a[100];                //массив на 100 символов
char *s = malloc(100);      //динамический массив на 100 символов, не забудь о free
```

Прочитать строку можно при помощи __scanf__ по формату %s.

```
#include <stdio.h>
int main() {
    char a[100];
    scanf("%s", a);       // читаем в массив а (НЕ ДЕЛАЙТЕ ТАК, НУЖЕН КОНТРОЛЬ ПЕРЕПОЛНЕНИЯ МАССИВА)
    printf("<%s>\n", a);  // печатаем прочитанное, спереди и сзади печатаем символ < и > , 
                          // чтобы увидеть где началась и закончилась строка
    return 0;
}
```

Программа принимает символы и печатает полученное. Результат работы программы показан ниже. Первая строка - то что вводим, вторая - что получаем на самом деле и выводим на печать

```
qaz wsxedc
<qaz>
```

Читается не вся строка, а "слово" до пробельного символа (пробела, табуляции, \n и тд).

```
   qaz123. wsxedc
<qaz123.>
```

Пробельные символы спереди пропускаются

Проблема такого считывания в возможном переполнении (количество символов может превышать 100). Для контроля переполнения можно использовать модификатор к формату __%<число>s__ (например %5s или %10s). __Число__ показывает не более скольки символов надо читать.

```
#include "stdio.h"

int main(){
    char a[10] = "hello";
    scanf("%3s", a);        //Читаем в массив а НЕ БОЛЕЕ 3 символов
    printf("<%s>\n", a);    //Печатаем прочитанное
    return 0;               
}
```

Программа выдаст Следущее:

```
qazxcvbnm wsxedc
<qaz>
```

Так как у нас закончилась печать на букве z потому что после нее в массиве шел символ \0.

Если в "слове" меньше символов чем указано в ограничении, то считывается только это "слово". "слово" - это последовательность символов до пробельного символа. 




