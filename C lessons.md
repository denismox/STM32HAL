# Справочник по C

## 1. Математические функции ```<math.h>```

```abs(int num)``` Модуль от целочисленного числа

```fabs(double num)``` Модуль от вещественного числа

```ceil(double num)``` Округление до большего целого

```cos(double num)``` Косинус от аргумента num, num должен быть задан в радианах

```floor(double num)``` Округление до ближайшего меньшего цисла

```exp(double num)``` Возвращает значение экспоненты от аргумента num

```log(double num)``` Возвращает значение натурального логарифма от num

```log10(double num)``` Возвращает значение десятичного логарифма от num

```pow(double base, double x)``` Возведение в аргумента ```base``` в степень ```x```

```sin(double num)``` Синус от аргумента num, num должен быть в радианах

```sqrt(double num)``` Извлечение корня квадратного из аргумента num

```tan(double num)``` Тангенс от аргумента num, num должен быть в радианах

## 1. Арифметические выражения в Си

### Составной оператор присваивания

Составной оператор присваивания имеет следущий вид: 
```x <оператор>= b;```

```<оператор>``` это один из десяти операторов ```+ - * / % << >> & | ^```

Например ```x += dx``` ```p *= i```

### Приоритет и ассоциативность операций

Каждая операция имеет вполне определенный **приоритет** и **ассоциативность**.

**Приоритет** - формальное свойство оператора, влияющее на очередность его выполнения в выражении с несколькими различными операторами при отсутствии явного (при помощи скобок) указания на порядок вычисления.

**Ассоциативность** - свойство операций, которое определяет порядок их выполнения при равном приоритете. Бывает двух видов: Левая ассоциативность (вычисления происходят слева направо) и правая ассоциативность (вычисления происходят справа налево)

В языке Си арифметические операции имеют левую ассоциативность, а операции присваивания - правую ассоциативность.

Таблица приоритета

![image](https://github.com/user-attachments/assets/537a8401-e4ed-4712-947b-3ed1248064c9)

### Преобразование типов

Преобразование типов бывает неявное(автоматическое) и явное

#### Неявное преобразование

При преобразовании типов используется принцип ранжирования. При использовании в выражении операндов, имеющих разные ранги, операнд, имеющий меньший ранг, приводится к типу операнда с высшим рангом. Например, если один из операндов имеет тип *long*, а второй *double*, то первый операнд преобразовывается к типу *double*. Все короткие типы (short) преобразуются к типу int.

Таблица рангов типов

![image](https://github.com/user-attachments/assets/5e0e4dcf-e57c-42f5-9e96-ec8d3353eab0)

#### Явное преобразование

Явное преобразование типов выглядит следущим образом:

```(тип)выражение```

Например: ```res = (float) (x*y/5)``` или ```res = a / (float)b```

#### Преобразование типа при присваивании

При присванивании разных типов выполняется следущее правило: **тип значения выражения приводится к типу переменной**

Это может приводить к потере информации, например следущий код:

```
#include<stdio.h>

int main()
{
  short small = 1297;
  long big = 32538261;

  small = big;

  printf("%hd %ld", small, big);

  return 0;
}
```

Вернет:

```32405 32538261```




