# Справочник по C

## Содержание 

[1. Функции ввода/вывода](#IO)

[2. Математические функции ```<math.h>```](#math.h)

[3. Арифметические выражения в Си](#arithmetic)

[4. Представление памяти программы](#memory)

[5. Генерация случайных чисел в языке Си](#rand)

[6. Условные операторы](#operators)

[7. Функции и указатели](#functions)

<a name="IO"><h2>1. Функции ввода/вывода</h2></a>

### Функция стандартного вывода

Для данных функций необходимо подключить библиотеку ```stdio.n```

```printf("<форматная строка>", <список вывода>);```

Например:

```
printf("A long time ago, in a galaxy far, far away...\n");
```

>A long time ago, in a galaxy far, far away...

```
printf("%d.%d.%d", 11, 12, 1990);
```

>	11.12.1990

### Функция стандартного вывода

`scanf("<Форматная строка>", <&Список ввода>);`

Так как `scanf` осуществляет запись введенного числа в память, то в качестве параметров ей передается не значение переменной, а ее __адрес__ (через взятие адреса __&__).

Например:

```
printf("Введите дату в формате <dd.mm.yyyy>:\n");
scanf_s("%d.%d.%d", &day, &month, &year);
printf("Ваша дата: %d/%d/%d", day, month, year);
```

>Введите дату в формате <dd.mm.yyyy>:
>
>09.08.2023
>
>Ваша дата: 09/08/2023

### Символы-спецификаторы

Любая спецификация преобразования начинается знаком % и заканчивается символом спецификатором. Спецификаторы и соответствующие им аргументы должны быть согласованы по количеству и типам: в противном случае напечатано будет не то, что нужно.

![image](https://github.com/user-attachments/assets/86cfa23d-1c5d-43ca-a576-5706acdb181c)

#### Общий синтаксис спецификатора формата

`%[флаг][ширина][. точность][длина]спецификатор`

Таблица флагов

![image](https://github.com/user-attachments/assets/def5a1bc-d9e2-4d83-b2cf-bb42dc091225)

__Ширина__ - минимальная ширина поля. Если выводимое число меньше ширины, то оставшееся пространство будет заполнено нулями.

__Точность__ - максимальное количество печатаемых символов в строке, или количество цифр после десятичной точки для чисел с плавающей запятой, или минимальное количество цифр для целого.

__Длина__ - размер позволяет указать размер данных, переданных функции. h: для ввода значений типа short int (%hd). l: для ввода значений типа long int (%ld) или double (%lf, %le). L: для ввода значений типа long double (%Lf, %Le)

<a name="math.h"><h2>2. Математические функции ```<math.h>```</h2></a>


```abs(int num)``` Модуль от целочисленного числа

```fabs(double num)``` Модуль от вещественного числа

```ceil(double num)``` Округление до большего целого

```cos(double num)``` Косинус от аргумента num, num должен быть задан в радианах

```floor(double num)``` Округление до ближайшего меньшего цисла

```exp(double num)``` Возвращает значение экспоненты от аргумента num

```log(double num)``` Возвращает значение натурального логарифма от num

```log10(double num)``` Возвращает значение десятичного логарифма от num

```pow(double base, double x)``` Возведение в аргумента ```base``` в степень ```x```

```sin(double num)``` Синус от аргумента num, num должен быть в радианах

```sqrt(double num)``` Извлечение корня квадратного из аргумента num

```tan(double num)``` Тангенс от аргумента num, num должен быть в радианах

<a name="arithmetic"><h2>3. Арифметические выражения в Си</h2></a>

### Составной оператор присваивания

Составной оператор присваивания имеет следущий вид: 
```x <оператор>= b;```

```<оператор>``` это один из десяти операторов ```+ - * / % << >> & | ^```

Например ```x += dx``` ```p *= i```

### Приоритет и ассоциативность операций

Каждая операция имеет вполне определенный **приоритет** и **ассоциативность**.

**Приоритет** - формальное свойство оператора, влияющее на очередность его выполнения в выражении с несколькими различными операторами при отсутствии явного (при помощи скобок) указания на порядок вычисления.

**Ассоциативность** - свойство операций, которое определяет порядок их выполнения при равном приоритете. Бывает двух видов: Левая ассоциативность (вычисления происходят слева направо) и правая ассоциативность (вычисления происходят справа налево)

В языке Си арифметические операции имеют левую ассоциативность, а операции присваивания - правую ассоциативность.

Таблица приоритета

![image](https://github.com/user-attachments/assets/537a8401-e4ed-4712-947b-3ed1248064c9)

### Преобразование типов

Преобразование типов бывает неявное(автоматическое) и явное

#### Неявное преобразование

При преобразовании типов используется принцип ранжирования. При использовании в выражении операндов, имеющих разные ранги, операнд, имеющий меньший ранг, приводится к типу операнда с высшим рангом. Например, если один из операндов имеет тип *long*, а второй *double*, то первый операнд преобразовывается к типу *double*. Все короткие типы (short) преобразуются к типу int.

Таблица рангов типов

![image](https://github.com/user-attachments/assets/5e0e4dcf-e57c-42f5-9e96-ec8d3353eab0)

#### Явное преобразование

Явное преобразование типов выглядит следущим образом:

```(тип)выражение```

Например: ```res = (float) (x*y/5)``` или ```res = a / (float)b```

#### Преобразование типа при присваивании

При присванивании разных типов выполняется следущее правило: **тип значения выражения приводится к типу переменной**

Это может приводить к потере информации, например следущий код:

```
#include<stdio.h>

int main()
{
  short small = 1297;
  long big = 32538261;

  small = big;

  printf("%hd %ld", small, big);

  return 0;
}
```

Вернет:

```32405 32538261```


<a name="memory"><h2>4. Представление памяти программы</h2></a>

Память бывает трех видов:

1. __Статическая память__ - выделяется при запуске программы до вызова функции main из свободной оперативной памяти и используется для размещения глобальных и статических объектов (например глобальные переменные).

2. __Автоматическая память (стек)__ - резервируется при запуске программы до вызова функции main из свободной оперативной памяти и используется в дальнейшем для размещения локальных объектов, определяемых в теле функций, и агрументов функций в момент их вызова (тут лежат локальные переменные)

3. __Динамическая память__ - совокупность нескольких блоков, выделяемых из доступной свободной памяти непосредственно во время выполнения программы под размещение динамически создаваемых объектов

   ![image](https://github.com/user-attachments/assets/cbd6f36c-5bf0-407d-85cf-1eae56d89255)


<a name="rand"><h2>5. Генерация случайных чисел в языке Си</h2></a>

Функция `rand()` возвращает случайное целое число в диапазоне от нуля до _RAND_MAX_. Эта функция определена в заголовочном файле `stdlin.h`.

```#include "stdlib.h"```

```num1 = rand();```

Генерация псевдослучайных чисел обеспечивается начальным случайным числом или "зерном". Одно и то же начальное значение каждый раз будет генерировать одну и ту же последовательность. Чтобы этого не происходило необходимо каждый раз определять зерно новым числом. Это можно сделать при помощи функции `srand()`.

Функция `srand()` инициализирует генератор случайных чисел начальным числом. Например `srand(666);`.

Чтобы каждый раз было случайное число можно воспользоваться функцией `time();`

`srand(time(NULL))` Функция time(NULL) - возвращает количество секунд, прошедших с 1 января 1970 года (Unix-время).

#### Ограничение псевдослучайных чисел определенным диапазоном

Нижняя граница 0. Но ее можно понизить вичитая необходимое число:

`num = -10 + rand();

Верхнюю границу можно понизить путем взятия остатка от деления. Например `rand() % 11 может вернуть число от 0 до 10 так как остаток от деления на 11 не может быть больше 10.

Поэтому. Чтобы взять определенную границу, например (-10; 10) необходимо воспользоваться формулой:

```
int min = -10, max = 10;
int rand_number;

rand_number = min + rand() % (max - min + 1);
```

<a name="operators"><h2>6. Условные операторы</h2></a>

### Условный оператор if

В общем виде условный оператор имеет вид:

```
if (<условие>) {
       <действия>
} else if{
       <действия>
} else {
      <действия>
}
```

При этом есть и другие варианты написания условного оператора if


```
if (<условие>)
       <действиЕ>;
else if (<условие>)
       <действиЕ>;
else if (<условие>) {
       <действия>
} else
       <действиЕ>;

```

Или такой

```
if (<условие>) <действиЕ>;
else if (<условие>) <действиЕ>;
else if (<условие>) { <действиЯ> }
else <действиЕ>;
```

### Тернарный оператор

Синтаксис оператора:

`<условие> ? <инстина> : <ложь>`

Если условие выполняется, то тернарный оператор возвращает _истину_, если не выполняется то возвращает <ложь>

Например:

```
int a = 2;
int b = 5;
int c = 10;

(a > b) ? c : -c;
```

>Программа вернет -10 (-c).

### Оператор множественного выбора switch

Синтаксис оператора:

```
switch (<переменная>){
 case <константа1>:
   <Операция1>;
   break;
 case <константа2>:
   <Операция2>;
   break;
...
 default:
   <Операция если ни один case не подошел>;
}
```

Значение _переменной_, указанной в условии switch сравнивается со значениями, которые следуют за словом case. Когда значение в переменной, соответствует значению в строке с оператором case, компьютер продолжит выполнение с _операции_ соответствующего кейса. 
Константы в case должны быть целочисленными (int, char и тд.)
Если не добавлять оператор break, то выполняются все действия с совпавшего case, те если совпал case3, то выполнятся все условия начиная с условия3.

Пример:

```
switch (n) {
 case 1:
    printf("Понедельник");
    break;
 case 2: 
    printf("Вторник");
    break;
 case 3: 
    printf("Среда");       
    break;
 case 4: 
    printf("Четверг");     
    break;
 case 5: 
    printf("Пятница");    
    break;
 case 6: 
    printf("Суббота");     
    break;
 case 7: 
    printf("Воскресенье"); 
    break;
 default: 
    printf("Неверный номер");
}
```
>При вводе n = 6 получим вывод:
>
>Суббота

Пример с выводом количества дней в месяце по номеру месяца:

```
switch(month) {
           case 1: case 3: case 5: case 7: case 8: case 10: case 12:
               printf("31\n");
               break;

           case 4: case 6: case 9: case 11:
               printf("30\n");
               break;

           case 2:
               printf("28\n");
               break;

           default:
               printf("Неверный номер месяца\n");
       }
```

<a name="functions"><h2>7. Функции и указатели</h2></a>

### Определение и вызов функции

Функция имеет следущий вид:

```
тип_возвращаемого_значения имя_функции(аргументы через запятую)
{
    тело функции
    return <что возвращаем>;
}
```
__имя_функции__ задает пользователь

__аргументы__ - _тип аргумента_ _имя аргумента_. У каждого аргумента должен быть прописан тип отдельно.

__тело функции__ - код, который выполняется во время вызова функции.

Оператор __return__ - возвращает значение из функции. _Выход из функции и вынос результата_.

__тип возвращаемого значения__ - тип того, что вернул оператор _return_. Если функция ничего не возврашает, то пишут тип _void_, в таком случае оператор _return_ можно не писать.

### Стандартные функции языка Си

Информация о стандартных функциях языка си содержится в 3-м томе справочника, например:

```man 3 sin```

![image](https://github.com/user-attachments/assets/921b1771-881a-4460-9966-be94c536368f)

### Прототип функции

Выше вызова фунции (выше функции _main_) должена быть реализация функции или ее прототип. Прототип позволяет объявить функцию, а ее реализацию прописать ниже функции _main_

Прототип получится если __тело функции__ заменить на __;__

```
float fahr(int cel);    // прототип

int main()
{
    float f;
    f = fahr(cel);      // вызов функции
    return 0;
}


float fahr(int cel)     // определение (реализация) функции
{
    return (cel * 1.8) + 32;
}
```

### Адреса и Указатели

Адрес - номер байта

Байт - самая маленькая единица памяти с адресом. Бит еще меньше, но адреса у него нет. В современных компьютерах как правило байт - это 8 бит.

Схематичное изображение памяти:

![image](https://github.com/user-attachments/assets/99efaf34-9db1-4384-b689-df2421718b08)

Предположим что переменная _х_ лежит по адресу 100 (т.е. занимает 4 байта: 100, 101, 102, 103), переменная _y_ по адресу 104, переменная _z_ по адресу 200.

Адреса - это числа. Их можно вычислять и хранить в переменных.

Оператор ```&``` называется оператором __взятия адреса__

Пусть переменная _x_ расположена по адресу 100 и ее значение 7:

```int x = 7; // Предположим что х расположена по адресу 100```

![image](https://github.com/user-attachments/assets/60f89485-f058-41f3-9cd5-ad50366325b9)

Сохраним этот адрес в переменную:

```
int x = 7;
int * px; // Объявили переменную px (pointer to x) типа int * (тип "Указатель на инт")
px = &x;
```

Таким образом px имеет тип _int *_ и значение _100_

![image](https://github.com/user-attachments/assets/862afa30-8c36-4e63-8fc2-ccfc63fc97a1)

Оператор ```*``` - это оператор разыменования. Оператор ```*``` обратный оператору ```&```. ```*``` по адресу находит значение, которое там записано.

Он позволяет работать с самими данными вместо адреса

```int y = *px + 3;```

_px_ имеет тип _int *_ и значение 100. Это __адрес данных__

_*px_ имеет тип _int_. Чтобы вычислить значение _*px_ нужно перейти по адресу 100, взять байты в которых храниться переменная px (100, 101, 102, 103) и прочитать число, лежащее в этих байтах, как int. __Получим число 7__, те __сами данные__.

Таким образом ```y = 10```

Для печати адреса используется формат ```%p```. Адрес печатается в шестнадцатиричном формате. 

В языке Си нельзя возвращать несколько значений переменных, поэтому если необходимо изменить несколько переменных за один вызов функции, то необходимо использовать адреса и указатели. Например как в функции ```scanf()```. 

Пример:

```
#include "stdio.h"

void min2time(int mm, int *h, int *m);

int main()
{
    int mm, h, m;
    scanf("%d", &mm);
    man2time(mm, &h, &m);
    printf("%02d:%02d", h, m);
    return 0;
}

void min2time(int mm, int *h, int *m)
{
    mm %= 1440;
    *h = mm / 60;
    *m = mm % 60;
}
```

В данном коде за один вызов функции min2time при помощи указателей изменяем значение переменных _h_ и _m_.



