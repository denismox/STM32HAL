# Справочник по C

## 1. Функции ввода/вывода

### Функция стандартного вывода

Для данных функций необходимо подключить библиотеку ```stdio.n```

```printf("<форматная строка>", <список вывода>);```

Например:

```
printf("A long time ago, in a galaxy far, far away...\n");
```

>A long time ago, in a galaxy far, far away...

```
printf("%d.%d.%d", 11, 12, 1990);
```

>	11.12.1990

### Функция стандартного вывода

`scanf("<Форматная строка>", <&Список ввода>);`

Так как `scanf` осуществляет запись введенного числа в память, то в качестве параметров ей передается не значение переменной, а ее __адрес__ (через взятие адреса __&__).

Например:

```
printf("Введите дату в формате <dd.mm.yyyy>:\n");
scanf_s("%d.%d.%d", &day, &month, &year);
printf("Ваша дата: %d/%d/%d", day, month, year);
```

>Введите дату в формате <dd.mm.yyyy>:
>
>09.08.2023
>
>Ваша дата: 09/08/2023

### Символы-спецификаторы

Любая спецификация преобразования начинается знаком % и заканчивается символом спецификатором. Спецификаторы и соответствующие им аргументы должны быть согласованы по количеству и типам: в противном случае напечатано будет не то, что нужно.

![image](https://github.com/user-attachments/assets/86cfa23d-1c5d-43ca-a576-5706acdb181c)

#### Общий синтаксис спецификатора формата

`%[флаг][ширина][. точность][длина]спецификатор`

Таблица флагов

![image](https://github.com/user-attachments/assets/def5a1bc-d9e2-4d83-b2cf-bb42dc091225)

__Ширина__ - минимальная ширина поля. Если выводимое число меньше ширины, то оставшееся пространство будет заполнено нулями.

__Точность__ - максимальное количество печатаемых символов в строке, или количество цифр после десятичной точки для чисел с плавающей запятой, или минимальное количество цифр для целого.

__Длина__ - размер позволяет указать размер данных, переданных функции. h: для ввода значений типа short int (%hd). l: для ввода значений типа long int (%ld) или double (%lf, %le). L: для ввода значений типа long double (%Lf, %Le)

## 1. Математические функции ```<math.h>```

```abs(int num)``` Модуль от целочисленного числа

```fabs(double num)``` Модуль от вещественного числа

```ceil(double num)``` Округление до большего целого

```cos(double num)``` Косинус от аргумента num, num должен быть задан в радианах

```floor(double num)``` Округление до ближайшего меньшего цисла

```exp(double num)``` Возвращает значение экспоненты от аргумента num

```log(double num)``` Возвращает значение натурального логарифма от num

```log10(double num)``` Возвращает значение десятичного логарифма от num

```pow(double base, double x)``` Возведение в аргумента ```base``` в степень ```x```

```sin(double num)``` Синус от аргумента num, num должен быть в радианах

```sqrt(double num)``` Извлечение корня квадратного из аргумента num

```tan(double num)``` Тангенс от аргумента num, num должен быть в радианах

## 2. Арифметические выражения в Си

### Составной оператор присваивания

Составной оператор присваивания имеет следущий вид: 
```x <оператор>= b;```

```<оператор>``` это один из десяти операторов ```+ - * / % << >> & | ^```

Например ```x += dx``` ```p *= i```

### Приоритет и ассоциативность операций

Каждая операция имеет вполне определенный **приоритет** и **ассоциативность**.

**Приоритет** - формальное свойство оператора, влияющее на очередность его выполнения в выражении с несколькими различными операторами при отсутствии явного (при помощи скобок) указания на порядок вычисления.

**Ассоциативность** - свойство операций, которое определяет порядок их выполнения при равном приоритете. Бывает двух видов: Левая ассоциативность (вычисления происходят слева направо) и правая ассоциативность (вычисления происходят справа налево)

В языке Си арифметические операции имеют левую ассоциативность, а операции присваивания - правую ассоциативность.

Таблица приоритета

![image](https://github.com/user-attachments/assets/537a8401-e4ed-4712-947b-3ed1248064c9)

### Преобразование типов

Преобразование типов бывает неявное(автоматическое) и явное

#### Неявное преобразование

При преобразовании типов используется принцип ранжирования. При использовании в выражении операндов, имеющих разные ранги, операнд, имеющий меньший ранг, приводится к типу операнда с высшим рангом. Например, если один из операндов имеет тип *long*, а второй *double*, то первый операнд преобразовывается к типу *double*. Все короткие типы (short) преобразуются к типу int.

Таблица рангов типов

![image](https://github.com/user-attachments/assets/5e0e4dcf-e57c-42f5-9e96-ec8d3353eab0)

#### Явное преобразование

Явное преобразование типов выглядит следущим образом:

```(тип)выражение```

Например: ```res = (float) (x*y/5)``` или ```res = a / (float)b```

#### Преобразование типа при присваивании

При присванивании разных типов выполняется следущее правило: **тип значения выражения приводится к типу переменной**

Это может приводить к потере информации, например следущий код:

```
#include<stdio.h>

int main()
{
  short small = 1297;
  long big = 32538261;

  small = big;

  printf("%hd %ld", small, big);

  return 0;
}
```

Вернет:

```32405 32538261```




