# Справочник по C

## Содержание 

[1. Функции ввода/вывода](#IO)

[2. Математические функции ```<math.h>```](#math.h)

[3. Арифметические выражения в Си](#arithmetic)

[4. Представление памяти программы](#memory)

[5. Генерация случайных чисел в языке Си](#rand)

[6. Условные операторы](#operators)

[7. Функции и указатели](#functions)

[8. Символы. Структуры](#symbol)

[8. Циклы](#cycle)

<a name="IO"><h2>1. Функции ввода/вывода</h2></a>

### Функция стандартного вывода

Для данных функций необходимо подключить библиотеку ```stdio.n```

```printf("<форматная строка>", <список вывода>);```

Например:

```
printf("A long time ago, in a galaxy far, far away...\n");
```

>A long time ago, in a galaxy far, far away...

```
printf("%d.%d.%d", 11, 12, 1990);
```

>	11.12.1990

### Функция стандартного вывода

`scanf("<Форматная строка>", <&Список ввода>);`

Так как `scanf` осуществляет запись введенного числа в память, то в качестве параметров ей передается не значение переменной, а ее __адрес__ (через взятие адреса __&__).

Например:

```
printf("Введите дату в формате <dd.mm.yyyy>:\n");
scanf_s("%d.%d.%d", &day, &month, &year);
printf("Ваша дата: %d/%d/%d", day, month, year);
```

>Введите дату в формате <dd.mm.yyyy>:
>
>09.08.2023
>
>Ваша дата: 09/08/2023

### Символы-спецификаторы

Любая спецификация преобразования начинается знаком % и заканчивается символом спецификатором. Спецификаторы и соответствующие им аргументы должны быть согласованы по количеству и типам: в противном случае напечатано будет не то, что нужно.

![image](https://github.com/user-attachments/assets/86cfa23d-1c5d-43ca-a576-5706acdb181c)

#### Общий синтаксис спецификатора формата

`%[флаг][ширина][. точность][длина]спецификатор`

Таблица флагов

![image](https://github.com/user-attachments/assets/def5a1bc-d9e2-4d83-b2cf-bb42dc091225)

__Ширина__ - минимальная ширина поля. Если выводимое число меньше ширины, то оставшееся пространство будет заполнено нулями.

__Точность__ - максимальное количество печатаемых символов в строке, или количество цифр после десятичной точки для чисел с плавающей запятой, или минимальное количество цифр для целого.

__Длина__ - размер позволяет указать размер данных, переданных функции. h: для ввода значений типа short int (%hd). l: для ввода значений типа long int (%ld) или double (%lf, %le). L: для ввода значений типа long double (%Lf, %Le)

<a name="math.h"><h2>2. Математические функции ```<math.h>```</h2></a>


```abs(int num)``` Модуль от целочисленного числа

```fabs(double num)``` Модуль от вещественного числа

```ceil(double num)``` Округление до большего целого

```cos(double num)``` Косинус от аргумента num, num должен быть задан в радианах

```floor(double num)``` Округление до ближайшего меньшего цисла

```exp(double num)``` Возвращает значение экспоненты от аргумента num

```log(double num)``` Возвращает значение натурального логарифма от num

```log10(double num)``` Возвращает значение десятичного логарифма от num

```pow(double base, double x)``` Возведение в аргумента ```base``` в степень ```x```

```sin(double num)``` Синус от аргумента num, num должен быть в радианах

```sqrt(double num)``` Извлечение корня квадратного из аргумента num

```tan(double num)``` Тангенс от аргумента num, num должен быть в радианах

<a name="arithmetic"><h2>3. Арифметические выражения в Си</h2></a>

### Составной оператор присваивания

Составной оператор присваивания имеет следущий вид: 
```x <оператор>= b;```

```<оператор>``` это один из десяти операторов ```+ - * / % << >> & | ^```

Например ```x += dx``` ```p *= i```

### Приоритет и ассоциативность операций

Каждая операция имеет вполне определенный **приоритет** и **ассоциативность**.

**Приоритет** - формальное свойство оператора, влияющее на очередность его выполнения в выражении с несколькими различными операторами при отсутствии явного (при помощи скобок) указания на порядок вычисления.

**Ассоциативность** - свойство операций, которое определяет порядок их выполнения при равном приоритете. Бывает двух видов: Левая ассоциативность (вычисления происходят слева направо) и правая ассоциативность (вычисления происходят справа налево)

В языке Си арифметические операции имеют левую ассоциативность, а операции присваивания - правую ассоциативность.

Таблица приоритета

![image](https://github.com/user-attachments/assets/537a8401-e4ed-4712-947b-3ed1248064c9)

### Преобразование типов

Преобразование типов бывает неявное(автоматическое) и явное

#### Неявное преобразование

При преобразовании типов используется принцип ранжирования. При использовании в выражении операндов, имеющих разные ранги, операнд, имеющий меньший ранг, приводится к типу операнда с высшим рангом. Например, если один из операндов имеет тип *long*, а второй *double*, то первый операнд преобразовывается к типу *double*. Все короткие типы (short) преобразуются к типу int.

Таблица рангов типов

![image](https://github.com/user-attachments/assets/5e0e4dcf-e57c-42f5-9e96-ec8d3353eab0)

#### Явное преобразование

Явное преобразование типов выглядит следущим образом:

```(тип)выражение```

Например: ```res = (float) (x*y/5)``` или ```res = a / (float)b```

#### Преобразование типа при присваивании

При присванивании разных типов выполняется следущее правило: **тип значения выражения приводится к типу переменной**

Это может приводить к потере информации, например следущий код:

```
#include<stdio.h>

int main()
{
  short small = 1297;
  long big = 32538261;

  small = big;

  printf("%hd %ld", small, big);

  return 0;
}
```

Вернет:

```32405 32538261```


<a name="memory"><h2>4. Представление памяти программы</h2></a>

Память бывает трех видов:

1. __Статическая память__ - выделяется при запуске программы до вызова функции main из свободной оперативной памяти и используется для размещения глобальных и статических объектов (например глобальные переменные).

2. __Автоматическая память (стек)__ - резервируется при запуске программы до вызова функции main из свободной оперативной памяти и используется в дальнейшем для размещения локальных объектов, определяемых в теле функций, и агрументов функций в момент их вызова (тут лежат локальные переменные)

3. __Динамическая память__ - совокупность нескольких блоков, выделяемых из доступной свободной памяти непосредственно во время выполнения программы под размещение динамически создаваемых объектов

   ![image](https://github.com/user-attachments/assets/cbd6f36c-5bf0-407d-85cf-1eae56d89255)


<a name="rand"><h2>5. Генерация случайных чисел в языке Си</h2></a>

Функция `rand()` возвращает случайное целое число в диапазоне от нуля до _RAND_MAX_. Эта функция определена в заголовочном файле `stdlin.h`.

```#include "stdlib.h"```

```num1 = rand();```

Генерация псевдослучайных чисел обеспечивается начальным случайным числом или "зерном". Одно и то же начальное значение каждый раз будет генерировать одну и ту же последовательность. Чтобы этого не происходило необходимо каждый раз определять зерно новым числом. Это можно сделать при помощи функции `srand()`.

Функция `srand()` инициализирует генератор случайных чисел начальным числом. Например `srand(666);`.

Чтобы каждый раз было случайное число можно воспользоваться функцией `time();`

`srand(time(NULL))` Функция time(NULL) - возвращает количество секунд, прошедших с 1 января 1970 года (Unix-время).

#### Ограничение псевдослучайных чисел определенным диапазоном

Нижняя граница 0. Но ее можно понизить вичитая необходимое число:

`num = -10 + rand();

Верхнюю границу можно понизить путем взятия остатка от деления. Например `rand() % 11 может вернуть число от 0 до 10 так как остаток от деления на 11 не может быть больше 10.

Поэтому. Чтобы взять определенную границу, например (-10; 10) необходимо воспользоваться формулой:

```
int min = -10, max = 10;
int rand_number;

rand_number = min + rand() % (max - min + 1);
```

<a name="operators"><h2>6. Условные операторы</h2></a>

### Условный оператор if

В общем виде условный оператор имеет вид:

```
if (<условие>) {
       <действия>
} else if{
       <действия>
} else {
      <действия>
}
```

При этом есть и другие варианты написания условного оператора if


```
if (<условие>)
       <действиЕ>;
else if (<условие>)
       <действиЕ>;
else if (<условие>) {
       <действия>
} else
       <действиЕ>;

```

Или такой

```
if (<условие>) <действиЕ>;
else if (<условие>) <действиЕ>;
else if (<условие>) { <действиЯ> }
else <действиЕ>;
```

__Если после условия нужно одно действие, то не обязательно ставить блочный оператор ```{}```__

Иногда можно встретить запись следущего вида:

```
if(x){
  ...
}
```

Это проверка на истину. Если в скобках будет TRUE (т.е. не 0) то выполняется условие и действия внутри блочного оператора. Если FALSE (т.е. 0), то условие не выполняется. 

Порядок имеет значени. Если есть несколько условий удовлетворяющих блоку if ... else, то выполнится первое подходящее, остальные при этом выполнены не будут, например:

```
int x = 7;

if (x >= 8)
    printf("отлично");
else if (x >= 3)
    printf("удовлетворительно");
else if (x >= 5)
    printf("хорошо");
else
    printf("неудовлетворительно");
```

Данный код выведет _удовлетворительно_

#### Логические операторы

- ```&&``` - логическое __И__ (AND, конъюнкция)
- ```||``` - логическое __ИЛИ__ (OR, дизъюнкция)
- ```!``` - логическое отрицание (NOT) - превращает ложь в истину и наоборот

__Не путать:__ ```&&``` и ```||``` - это логические операторы, а ```&``` и ```|``` - побитовые.

### Тернарный оператор

Синтаксис оператора:

`<условие> ? <инстина> : <ложь>`

Если условие выполняется, то тернарный оператор возвращает _истину_, если не выполняется то возвращает <ложь>

Например:

```
int a = 2;
int b = 5;
int c = 10;

(a > b) ? c : -c;
```

>Программа вернет -10 (-c).

### Оператор множественного выбора switch

Синтаксис оператора:

```
switch (<переменная>){
 case <константа1>:
   <Операция1>;
   break;
 case <константа2>:
   <Операция2>;
   break;
...
 default:
   <Операция если ни один case не подошел>;
}
```

Значение _переменной_, указанной в условии switch сравнивается со значениями, которые следуют за словом case. Когда значение в переменной, соответствует значению в строке с оператором case, компьютер продолжит выполнение с _операции_ соответствующего кейса. 
Константы в case должны быть целочисленными (int, char и тд.)
Если не добавлять оператор break, то выполняются все действия с совпавшего case, те если совпал case3, то выполнятся все условия начиная с условия3.

Пример:

```
switch (n) {
 case 1:
    printf("Понедельник");
    break;
 case 2: 
    printf("Вторник");
    break;
 case 3: 
    printf("Среда");       
    break;
 case 4: 
    printf("Четверг");     
    break;
 case 5: 
    printf("Пятница");    
    break;
 case 6: 
    printf("Суббота");     
    break;
 case 7: 
    printf("Воскресенье"); 
    break;
 default: 
    printf("Неверный номер");
}
```
>При вводе n = 6 получим вывод:
>
>Суббота

Пример с выводом количества дней в месяце по номеру месяца:

```
switch(month) {
           case 1: case 3: case 5: case 7: case 8: case 10: case 12:
               printf("31\n");
               break;

           case 4: case 6: case 9: case 11:
               printf("30\n");
               break;

           case 2:
               printf("28\n");
               break;

           default:
               printf("Неверный номер месяца\n");
       }
```

<a name="functions"><h2>7. Функции и указатели</h2></a>

### Определение и вызов функции

Функция имеет следущий вид:

```
тип_возвращаемого_значения имя_функции(аргументы через запятую)
{
    тело функции
    return <что возвращаем>;
}
```
__имя_функции__ задает пользователь

__аргументы__ - _тип аргумента_ _имя аргумента_. У каждого аргумента должен быть прописан тип отдельно.

__тело функции__ - код, который выполняется во время вызова функции.

Оператор __return__ - возвращает значение из функции. _Выход из функции и вынос результата_.

__тип возвращаемого значения__ - тип того, что вернул оператор _return_. Если функция ничего не возврашает, то пишут тип _void_, в таком случае оператор _return_ можно не писать.

### Стандартные функции языка Си

Информация о стандартных функциях языка си содержится в 3-м томе справочника, например:

```man 3 sin```

![image](https://github.com/user-attachments/assets/921b1771-881a-4460-9966-be94c536368f)

### Прототип функции

Выше вызова фунции (выше функции _main_) должена быть реализация функции или ее прототип. Прототип позволяет объявить функцию, а ее реализацию прописать ниже функции _main_

Прототип получится если __тело функции__ заменить на __;__

```
float fahr(int cel);    // прототип

int main()
{
    float f;
    f = fahr(cel);      // вызов функции
    return 0;
}


float fahr(int cel)     // определение (реализация) функции
{
    return (cel * 1.8) + 32;
}
```

### Адреса и Указатели

Адрес - номер байта

Байт - самая маленькая единица памяти с адресом. Бит еще меньше, но адреса у него нет. В современных компьютерах как правило байт - это 8 бит.

Схематичное изображение памяти:

![image](https://github.com/user-attachments/assets/99efaf34-9db1-4384-b689-df2421718b08)

Предположим что переменная _х_ лежит по адресу 100 (т.е. занимает 4 байта: 100, 101, 102, 103), переменная _y_ по адресу 104, переменная _z_ по адресу 200.

Адреса - это числа. Их можно вычислять и хранить в переменных.

Оператор ```&``` называется оператором __взятия адреса__

Пусть переменная _x_ расположена по адресу 100 и ее значение 7:

```int x = 7; // Предположим что х расположена по адресу 100```

![image](https://github.com/user-attachments/assets/60f89485-f058-41f3-9cd5-ad50366325b9)

Сохраним этот адрес в переменную:

```
int x = 7;
int * px; // Объявили переменную px (pointer to x) типа int * (тип "Указатель на инт")
px = &x;
```

Таким образом px имеет тип _int *_ и значение _100_

![image](https://github.com/user-attachments/assets/862afa30-8c36-4e63-8fc2-ccfc63fc97a1)

Оператор ```*``` - это оператор разыменования. Оператор ```*``` обратный оператору ```&```. ```*``` по адресу находит значение, которое там записано.

Он позволяет работать с самими данными вместо адреса

```int y = *px + 3;```

_px_ имеет тип _int *_ и значение 100. Это __адрес данных__

_*px_ имеет тип _int_. Чтобы вычислить значение _*px_ нужно перейти по адресу 100, взять байты в которых храниться переменная px (100, 101, 102, 103) и прочитать число, лежащее в этих байтах, как int. __Получим число 7__, те __сами данные__.

Таким образом ```y = 10```

Для печати адреса используется формат ```%p```. Адрес печатается в шестнадцатиричном формате. 

В языке Си нельзя возвращать несколько значений переменных, поэтому если необходимо изменить несколько переменных за один вызов функции, то необходимо использовать адреса и указатели. Например как в функции ```scanf()```. 

Пример:

```
#include "stdio.h"

void min2time(int mm, int *h, int *m);

int main()
{
    int mm, h, m;
    scanf("%d", &mm);
    man2time(mm, &h, &m);
    printf("%02d:%02d", h, m);
    return 0;
}

void min2time(int mm, int *h, int *m)
{
    mm %= 1440;
    *h = mm / 60;
    *m = mm % 60;
}
```

В данном коде за один вызов функции min2time при помощи указателей изменяем значение переменных _h_ и _m_.

Указатель с двумя звездами - это указатель на указатель на ..., например ```int *px = &x; int **ppx = &px;```

Нельзя присваивать адрес указателю, если у них различаются типы данных. Тк могут несовпадать количество бай у этих типов.

```void *``` - это тип "просто адрес". такой тип нельзя разыменовывать, но к нему неявно или явно приводится любой тип.

```
int x = 7;
int *px = &x;
void *y = px;  //неявное приведения типа int* к void*
//или явное преобразование
*(int *)y
```

### Оператор sizeof

Оператор ```sizeof``` дает размер переменной или типа в байтах

Результат имеет тип ```size_t```

Чтобы напечатать результат этого оператора нужно использовать спецификатор ```%zu```

```printf("%zu", sizeof(*int));```

Все типы указателей имеют одинаковый размер:

```
/*Они все имеют одинаковый размер*/
sizeof(*int);
sizeof(*char);
sizeof(*double);
sizeof(**int);
...
```

Любой указатель должен быть инициализирован, если нет понимания чем, то можно использовать NULL

```int *p = NULL;```

### Глобальные переменные

__Глобальные переменные__ - это такие переменные, время жизни которых распротраняется на всю программу. Декларируются такие переменные вне функций. Область видимости от декларации до конца файла. 

Область видимости можно расширить при помощи ```extern```, поэтому глобальные переменные принято объявлять до объявления каких-либо функций

__НАЧАЛЬНОЕ ЗНАЧЕНИЕ ГЛОБАЛЬНЫХ ПЕРЕМЕННЫХ ПО УМОЛЧАНИЮ 0! (в отличии от локальных в которых будет лежать мусор)__

Вне функций нельзя делать действий с переменными, только объявлять.

```
#include <stdio.h>

int x = 5;  // это глобальная переменная х

void foo() {
    x = x + 1;
}

int main() {
    foo();
    foo();
    printf("x=%d\n", x);
    return 0;
}
```

### Переменные static

У статических переменных - время жизни распространяется до конца программы (как и у глобальных). Но область видимости ограничена.

Такие переменные объявляются с ключевым словом __static__

```static int x;```

Область видимости: весь файл от декларации, если объявлена вне функций, или внутри функции или блока если объявлена внутри функции или блока.

Область видимости нельзя расширить на другие файлы

__Начальное значение по умолчанию 0__

Инициализируются один раз.

Так как область видимости ограничена, то можно объявить разные статические переменные с одним и тем же именем в разных областях видимости.

### #define

В самом начале текст программы обрабатывается препроцессором. Он делает поиск текста и его замену.

![image](https://github.com/user-attachments/assets/8ae10c8e-4753-4b1c-b33f-ae32f2d5c39a)

Директивы препроцессора начинаются с ```#```. В конце директив не ставится ```;```

```#include <имя_файла>``` заменяет эту строку на содержимое файла _имя_файла_

```#define идетификатор текстовая_замена``` Заменяет идентификатор на все содержимое до конца строки - это называется __макроподстановка__ или __макрос__

```
#define A 3;    // поставили ; в конце
x = A + x;      // заменилось на x = 3; + x; - ошибка компиляции
```

Макросы могут быть с аргументами:

```
#define cube(x) x*x*x
y = cube(2) //y = 2*2*2
```

Чтобы небыло ошибок при использовании макроса нужно ставить скобки около каждого аргумента и около всего макроса:

```
#define cube(x) ((x)*(x)*(x))
```

Также при вызове макроса лучше не использовать __++__ или __--__. Для таких задач лучше использовать функции.

Также не стоит вызывать функции в макросах

### Условная компиляция

Макросы также позволяют выполнять только определенную часть кода, например:

```
#define AAA
#ifdef AAA
  //Часть кода, которая выполняется если определен макрос ААА (у нас определен)
#elif BBB
  //Часть кода, которая выполняется если определен макрос BBB (у нас не определен)
#else
  //Часть кода, которая выполняется если не определены остальные макросы
#endif
```

Можно не определять макрос ААА в коде программы, а указать его при компиляции в системе:

```gcc -DAAA hello.c```

ключ ```-D``` с аргументом ```AAA``` работает как ```#define AAA```

Полная и кратка форма макросов:

```
#ifdef BBB          // краткая форма
#if defined BBB     // полная форма
#if defined (BBB)   // полная форма

#ifndef BBB          // краткая форма
#if !defined BBB     // полная форма
#if !defined (BBB)   // полная форма
```

Можно отменить объявление макроса при помощи ```#undef AAA```

Существует 2 операции которые может выполнять препроцессор: __#__ и __##__

__#__ - заключает текст параметра в кавычки

__##__  - Позволяет объединить две лексемы

Тут "склеиваются" 3 числа

```
#include <stdio.h>
#define print(a,b,c) printf("%d", a##b##c);
 
int main(void)
{
    print(2, 81, 34);   // 28134
    return 0;
}
```

<a name="symbol"><h2>8. Символы. Структуры</h2></a>

### Символы

#### ASCII таблица

![image](https://github.com/user-attachments/assets/1974014e-c0d8-45aa-92a5-3be7b911f54a)

Коды символов как правило хранят в типе ```char``` размером 1 байт.

Чтобы не запоминать численное значение символа ввели понятие __символьная константа__. Она пишется в одинарных кавычках и обозначает код символа. Тип символьной константы __int__.

```'a' // значение: 97```

#### Чтение и печать одного символа

Для чтения с помощью ```scanf``` и печати ```printf``` используют форматный спецификатор __%c__

```
char x;
scanf("%c", &x);                            // нажмем на клавиатуре клавишу Q и далее Enter
printf("символ %c, ASCII код %d\n", x, x);  // символ Q, ASCII код 81
```

Есть специальные функции ```getchar``` и ```putchar```, которые читают и печатают один символ

```
int x;          // да, именно int
x = getchar();  // нажмем на клавиатуре клавишу Q и далее Enter
putchar(x);     // Q
```

Тип __int__ нужен для проверки на ошибку (только в getchar в scanf можно использовать char, так как в функциях с переменным числом аргументов любой целый тип, меньший _int_, будет неявно преобразован е _int_). Если символ пришел верно, то в старших байтах нули, а в младших число соответствующее ASCII-символу. В случае ошибки все биты станут равны 1 и функция вернет -1. Если использовать ```char x = getchar();``` то в случае ошибки в x будет число 255, что в некоторых кодировках совпадает с символом ```Ъ```

Чтобы получить из символа цифры эту же цифру нужно вычесть из сивольной константы ```'0'``` так как все символы идут по порядку начиная с нуля в ASCII.

```
char x = '3'
char y = '0' - x;  //y = 3;
```

Если изнальный тип переменной, в которую мы хотим записать значение при помощи ```scanf```, ```char```, то и записывать нужно со спецификатором _%hhd_ или _%c_, иначе в случае _int_ ASCII-код можно код будет записан в байт с наименьшим адресом (а старший или младший это байт зависит от архитектуры).

### Структуры

Структуры - это определяемый пользователем тип, который содержит данные, возможно разных типов

Структура состоит из полей. Каждое поле имеет __тип__ и __имя__.

```
struct Student {
  long id;
  int birth_year;
  float weight;
  float height;
  float run100;
  unsigned char pushup;
  unsigned char pullup;   // пишем поля
};                        // ; <== обязательно
```

Содержание:
1) Ключевое слово struct (нельзя опустить)
2) Student - имя структуры (принято писать с большой буквы);
3) Поля пишут в фигурных скобках ```{}```
4) Поля определяют как ```<тип> <идентификатор>``` (```long id;```). Поля могут быть разных типов.
5) __После объявления структуры обязательно ставить ;__

#### Объявление переменной:

С неявной идентификацией:

```
struct Student gusev;
```

С явной идентификацией:

```
struct Student ivanov = {321456, 2000, 70.4, 1.86, 17.6, 14, 5};
```

__Поля при явной идентификацией пишут в том же порядке что и при объявлении структуры.__

Можно инициализировать только часть полей:

```
struct Student petrov = {312456, 1999};    //только id и birth_year, остальные поля 0;
```

Чтобы при инициализации перечислять данные в любом порядке нужно указывать имя поля

```
struct Student sidorov = {.weight = 56.6, .height = 1.62, .id=345789};
```

При этом нельзя присваивать к уже созданной переменной анонимную структуру. Только при инициализации или при помощи приведения к типу ```struct Student```

```
struct Student zotov;         // ок
zotov = {198345, 2001, 61.9}; // ошбика
```

Правильно:

```
struct Student zotov;
zotov = (struct Student){198345, 2001, 61.9};  // ok
```

#### Копирование структуры

__Оператор ```=``` копирует структуры одинакового типа__

```zotov = sidorov``` //sidorov типа struct Student, как и zotov

__Нельзя копировать структуры разных типов, даже если у них одинаковые типы и количество полей__

```
struct Fruit {
    int price;    // рубли
    float weight; // кг
};
struct Human {
    int age;      // возраст, полных лет
    float height; // рост, метры
};


// полтора килограмма по 200 рублей за килограмм
struct Fruit apple = {.price = 200, .weight = 1.5};
struct Human vasya;
vasya = apple;                                      // Ошибка
vasya = (struct Human){18, 1.76};                   // ok
vasya = (struct Human){.age = 18, .height = 1.76};  // Ошибка
```

Здесь ```{18, 1.76}``` - экземпляр Анонимной структуры, поэтому нельзя присать ```{.age = 18, .height = 1.76};```, так как поля ```.age``` и ```.height``` относятся к ```struct Human```, а не к анонимной структуре.

#### Использование переменных

__Переменная.поле__ - обращение к полю переменной через оператор "точка"

```
struct Student zotov;
zotov.height = 1.72;
zotov.pullup = 9;


zotov.id = sidorov.id + 2;


printf("Самый высокий рост: %.2f\n", ivanov.height);


scanf("%d", &zotov.id); // скобки не нужны, приоритет . больше, чем приоритет &
```

#### Адрес структуры

В функцию можно также передавать адрес структуры, а не копию ее полей, и работать с адресами. Например:

```
void inc(struct Point *p){
(*p).x = (*p).x + 1;
}
```

Для удобства в Си есть оператор доступа к полю структуры ```->```

```
void inc(struct Point *p);

int main()
{
   struct Point t;
   t.x = 2;
   inc(&t);
   inc(&t);
   printf("%d\n", t.x);


   return 0;
}

void inc(struct Point * p)
{
    p->x = p->x + 1;
}
```

#### typedef

Для любого типа можно определить новое имя с помощью __typedef__:

```typedef <существующий тип> <псевдоним>```

```
typedef unsigned char Age;              // тип для хранения возраста человека в годах
typedef unsigned long long int llu;     // просто надоело писать длинные слова

unsigned char x;
Age student = 17;


llu z = (llu)x * x;
unsigned long long *p = &z;
```

- Псевдоним можно использовать там же, где используется тип.
- Можно использовать как псевдоним, так и исходный тип.
- Псевдоним - одно слово.
- Псевдоним принято писать с большой буквы (кроме низкоуровневых - ```llu``` и кроме системных - ```size_t```)
- Псевдониму нельзя дать системное имя (int, for, return и тд).

При помощи typedef можно не писать каждый раз слово struct

```
struct Point{
  int x;
  int y;
};
typedef struct Point Point;
```

То же самое, но можно соединить определение структуры с typedef:

```
typedef struct Point {
  int x;
  int y;
} Point;
```

#### Анонимные структуры

Можно определять структуры без указания имени. Такие структуры называеются анонимными.

Можно определить структуру, переменные и дальше их использовать.

```
struct {
  unsigned char age;
  float weight;
} man, woman, cat;

cat.age = 2;
cat.weight = 4.7;
```

Однако ананимные структуры не могут быть типом формального аргумента функции:

```int is_adult(struct p);  //ошибка. не существует тип struct```

Но если использовать псевдони при объявлении структуры, то можно использовать анонимную структуру везде где используем этот тип. Это сокращает запиcь:

```
typedef struct {
  int hour;
  int minute;
  int second;
} Time;

Time clock = {12, 34, 5};

int time2min(Time t);
Time man2time(int mm);
```

<a name="cycle"><h2>9. Циклы</h2></a>

### Цикл While

Оператор _while_ выполняет тело цикла если условие цикла истинно, затем опять проверяет условие, если условие ложно - передает управление на первый оператор за циклом.

```
while (условие продолжения цикла){
    тело цикла
}
```

Если в теле цикла одна строка, то ```{}``` можно не ставить. 

Также в цикле может быть несколько условий (по аналогии с _if_)

```
while (k > 0 && b = 1){
    тело цикла
}
```

#### Оператор do ... while

В операторе _while_ сначала проверяется условие, а потом выполняется тело цикла. В Операторе _do ... while_ сперва выполняется тело цикла, а хатем проверяется условие продолжение цикла.

```
do {
  тело цикла;
} while(условие продолжения цикла);
```

Этот цикл используется когда необходимо чтобы условие выполнилось хотябы один раз.

### Цикл for

Цикл _for_ имеет следущий вид:

```
for(выражение1; выражение2; выражение){
  Тело цикла;
}
```

_выражение1_ - это инициализация, выполняется один раз в начале цикла. Можно инициализировать несколько переменных через запятую ```for(int i = 0, double y = 2; ... ; ...)```

_выражение2_ - условие продолжения цикла. Условие может быть сложным. Без запятых, только логические операторы `&&`, `||`, `!`.

_выражение3_ - выполняется каждый раз после выполнения тела цикла. Может быть несколько операций через запятую `for(... ; ... ; i++, res += 10)`

В цикле _for_ можно пропустить любое из выражений.

```
for(;;)  //бесконечный цикл
  printf("Hello, world\n"); 
```

### break, continue, goto

Оператор `break;` - завершает работу текущего цикла или _switch_.

```
#include <stdio.h>

int main()
{
    int x;          // яблок на одной (текущей) яблоне
    int sum;        // уже собрали яблок
    int n;          // количество деревьев
    int i;          // сколько деревьев уже обработали

    scanf("%d", &n);

    sum = 0;        // не забыть очистить корзину перед сбором яблок!
    for(i= 0; i < n; i++) {
        scanf("%d", &x);
        if (x < 0) {                // если ВОРОНЫ
            printf("ВОРОНЫ!\n");
            break;                  // убегаем из ряда
        }
        sum += x;
        printf("i=%d x=%d sum=%d\n", i, x, sum);
    }
    // сюда передаст управление break
    printf("%d\n", sum);
    return 0;
}
```

Оператор `continue;` - управление передается на следущую итерацию цикла.

```
#include <stdio.h>

int main()
{
    int x;          // яблок на одной (текущей) яблоне
    int sum;        // уже собрали яблок
    int n;          // количество деревьев
    int i;          // сколько деревьев уже обработали

    scanf("%d", &n);

    sum = 0;        // не забыть очистить корзину перед сбором яблок!
    for(i= 0; i < n; i++) {         //сюда попадет программа после continue (начнет с i++)
        scanf("%d", &x);
        if (x < 0) {                // если ВОРОНЫ
            printf("ВОРОНЫ!\n");
            continue;               // идем к следующей яблоне
        }
                                    // этот код тоже не выполняется при continue
        sum += x;
        printf("i=%d x=%d sum=%d\n", i, x, sum);
    }
    printf("%d\n", sum);
    return 0;
}
```

Оператор `goto МЕТКА;` позволяет переходит к МЕТКЕ выше или ниже по коду. Метка ставиться `МЕТКА:`

- Все метки должны иметь разные имена
- Разные `goto` могут вести к одной метке
- `goto` не может передать управление вне функции. Тоесть метка и переход на нее должны находится в одной функции.

Оператор `goto` понижает читаемость кода. Его следует использовать как аналог к операторам `break` и `continue` во вложенных циклах.

Пример использования `goto`:

__goto L;__ - `break` по внешнему циклу. Управление передается сразу за циклом (после `}`)
__goto K;__ - `continue` по внешнему циклу. Управление передается на `j++`

```
int main()
{
A:  
    int rows, j, total, n, i, x, sum;
B:  
    scanf("%d", &rows);
    total = 0;
C:  
    for (j = 0; j < rows; j++) {
D:
        scanf("%d", &n);
        sum = 0;        // не забыть очистить корзину перед сбором яблок!
E:
        for(i= 0; i < n; i++) {
F:          
            scanf("%d", &x);
            if (x < 0)
                goto ???;       // куда переходить?
            sum += x;
            printf("j=%d i=%d x=%d sum=%d\n", j, i, x, sum);
G:          
        }
H:      
        total += sum;
        printf("j=%d total=%d\n", j, total);
K:      
    }   
L:  
    printf("%d\n", total);
M:  
    return 0;
}
```

